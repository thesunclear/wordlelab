<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wordle Lab ‚Äì Advanced Wordle Solver & Analyzer</title>
  <meta name="description" content="Wordle Lab is an advanced Wordle solver and analyzer that recommends optimal guesses using entropy-based analysis, E[steps], E[cands], and Max Bucket metrics." />
  <meta name="keywords" content="Wordle, Wordle Solver, Wordle Helper, Wordle Analyzer, Wordle Strategy, Entropy, E[steps], E[cands], Max Bucket, Wordle Lab" />
  <meta name="author" content="Jaehong Kim" />
  <meta name="robots" content="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1">
  <meta name="theme-color" content="#0f1115">

  <!-- Open Graph (for Facebook, LinkedIn, etc.) -->
  <meta property="og:title" content="Wordle Lab ‚Äì Advanced Wordle Solver & Analyzer" />
  <meta property="og:description" content="Wordle Lab is an advanced Wordle solver and analyzer that recommends optimal guesses using entropy-based analysis, E[steps], E[cands], and Max Bucket metrics." />
  <meta property="og:url" content="https://wordlelab.com/" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://wordlelab.com/preview.png" />

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Wordle Lab ‚Äì Advanced Wordle Solver & Analyzer" />
  <meta name="twitter:description" content="Wordle Lab is an advanced Wordle solver and analyzer that recommends optimal guesses using entropy-based analysis, E[steps], E[cands], and Max Bucket metrics." />
  <meta name="twitter:image" content="https://wordlelab.com/preview.png" />
  <meta name="twitter:site" content="@DrDrTwice" />
  
  <!-- Canonical URL -->  
  <link rel="canonical" href="https://wordlelab.com/" />
  
  

  <!-- Favicons & PWA -->
  <link href="./apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180"/>
  <link href="./favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"/>
  <link href="./favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"/>
  <link href="./site.webmanifest" rel="manifest"/>
  

  
    <!-- ===== Structured Data (JSON-LD) ===== -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "Wordle Lab",
    "url": "https://wordlelab.com/",
    "applicationCategory": "EducationalApplication",
    "operatingSystem": "Web",
    "description": "Wordle Lab is a powerful Wordle helper and analyzer for optimal guesses and entropy-based recommendations.",
    "inLanguage": ["en"],
    "keywords": [
      "Wordle lab", "Wordle helper", "Wordle analyzer", "Wordle solver",
      "Wordle entropy", "E[steps]", "expected candidates",
      "Max Bucket", "next guess recommender", "Hard Mode"
    ],
    "author": { "@type": "Person", "name": "Jaehong Kim" }
  }
  </script>
  
  <style>
   *,*::before,*::after{box-sizing:border-box}

	/* Without Background Image 

    :root{
      --bg:#0f1115;--fg:#e6ebf2;--sub:#aab3c2;--muted:#667085;
      --card:#161a22;--accent:#7aa2f7;--good:#22c55e;--bad:#ef4444;
      --warn:#f59e0b;--btn:#222938;--btnHover:#2b3550;
      --border:#212836;--input:#0b0e14;
    }
    body.light{
      --bg:#f8fafc;--fg:#0f172a;--sub:#334155;--muted:#64748b;
      --card:#ffffff;--accent:#3b82f6;--good:#16a34a;--bad:#dc2626;
      --warn:#d97706;--btn:#e2e8f0;--btnHover:#cbd5e1;
      --border:#dbe1ea;--input:#f1f5f9;
    }
	
	html,body{height:100%}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font:14px/1.5 system-ui,Segoe UI,Inter,Roboto,Arial}   

	Without Background Image */
   
	/* Background Image */
    :root{
      /* Dark (default) */
      --bg:#0f1115;--fg:#e6ebf2;--sub:#aab3c2;--muted:#667085;
      --card:#161a22;--accent:#7aa2f7;--good:#22c55e;--bad:#ef4444;
      --warn:#f59e0b;--btn:#222938;--btnHover:#2b3550;
      --border:#212836;--input:#0b0e14;
      /* Background tuning for DARK */
      --overlay: rgba(10,12,16,.35);
      --bg-bright: .75;
      --bg-blur: 1px;
    }
    body.light{
      /* Light */
      --bg:#f8fafc;--fg:#0f172a;--sub:#334155;--muted:#64748b;
      --card:#ffffff;--accent:#3b82f6;--good:#16a34a;--bad:#dc2626;
      --warn:#d97706;--btn:#e2e8f0;--btnHover:#cbd5e1;
      --border:#dbe1ea;--input:#f1f5f9;
    }

    html,body{height:100%}
    html,body{margin:0;padding:0;background:transparent;color:var(--fg);font:14px/1.5 system-ui,Segoe UI,Inter,Roboto,Arial}
    /* Light: disable background image */
    body.light{ background: var(--bg); }
    body.light::before, body.light::after{ content:none !important; }

    /* Dark: background image visible */
    body::before{
      content:""; position:fixed; inset:0;
      background:url('./background.jpg') center/512px repeat;
      filter: brightness(var(--bg-bright)) saturate(.95) blur(var(--bg-blur));
      z-index:-2; will-change:transform;
    }
    body::after{ content:""; position:fixed; inset:0; background:var(--overlay); z-index:-1; }

	/* Background Image */

    .wrap{max-width:1000px;margin:0 auto;padding:20px}
    h1{font-size:20px;margin:0}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:14px;min-width:0;box-shadow:0 6px 18px rgba(0,0,0,.15)}
    .btn{background:var(--btn);border:1px solid var(--border);color:var(--fg);border-radius:10px;padding:8px 12px;cursor:pointer}
    .btn[disabled]{opacity:.6;cursor:not-allowed}
    .btn:hover{background:var(--btnHover)}
    input[type="file"]{display:none}
    .filelabel{display:inline-block}
    .tag{color:var(--sub);font-size:12px;margin-left:6px}
    .bar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .search{flex:1;min-width:220px;max-width:700px}
    .search input{width:100%;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:var(--input);color:var(--fg)}

    /* Key grids */
    .grid{display:grid;grid-template-columns:repeat(13,minmax(28px,1fr));gap:6px}
    .k{display:flex;align-items:center;justify-content:center;border-radius:8px;border:1px solid var(--border);background:var(--input);height:34px;cursor:pointer;user-select:none}
    .k.inc{background:rgba(34,197,94,.18);border-color:#1f9b56}
    .k.exc{background:rgba(239,68,68,.20);border-color:#a12828}

    /* Tabs */
    .tabs{display:grid;grid-template-columns:repeat(5, 1fr);gap:8px}
    .tab{padding:6px 10px;text-align:center;border-radius:10px;border:1px solid var(--border);background:var(--input);color:var(--fg);cursor:pointer;white-space:nowrap;min-width:0}
    .tab.active{outline:2px solid var(--accent)}

    /* List */
    .list{max-height:60vh;overflow:auto;border:1px solid var(--border);border-radius:12px}
    .list ul{list-style:none;margin:0;padding:0}
    .list li{padding:10px 12px;border-bottom:1px solid var(--border);font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .list li:last-child{border-bottom:none}
    small{color:var(--muted)} .hint{color:var(--sub)}
    .counter{font-size:18px;font-weight:700;margin:14px 2px 6px 2px;color:var(--fg)}
    .counter small{font-weight:500;color:var(--sub)}
    .header-row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px}
    .header-row .btn{padding:6px 10px}

    /* Help */
    .help{margin-top:18px;color:var(--sub);font-size:13px;line-height:1.45}
    .help ul{margin:6px 0 0 18px;padding:0}
    .help li{margin-bottom:4px}
    .help code{background:var(--input);border-radius:5px;padding:1px 4px;font-family:ui-monospace,monospace}

    /* Suggestion table */
    table{width:100%;border-collapse:collapse}
    thead th{font-weight:600;text-align:left;border-bottom:1px solid var(--border);padding:8px}
    tbody td{padding:8px;border-bottom:1px solid var(--border);font-family:ui-monospace,monospace}
    .mono{font-family:ui-monospace,monospace}

    /* Recommender controls */
    .ctl{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .ctl label{font-size:13px;color:var(--sub);display:flex;gap:6px;align-items:center}
    .ctl input[type="number"]{width:86px;padding:6px;border-radius:8px;border:1px solid var(--border);background:var(--input);color:var(--fg)}
    .ctl select{padding:6px;border-radius:8px;border:1px solid var(--border);background:var(--input);color:var(--fg)}
    .progress{height:6px;background:var(--input);border:1px solid var(--border);border-radius:999px;overflow:hidden}
    .barin{height:100%;background:var(--accent);width:0%}

    /* Responsive */
    @media(max-width:1024px){#gInc,#gExc,#pInc,#pExc{grid-template-columns:repeat(12,minmax(28px,1fr))}}
    @media(max-width:960px){#gInc,#gExc,#pInc,#pExc{grid-template-columns:repeat(11,minmax(28px,1fr))}}
    @media(max-width:900px){#gInc,#gExc,#pInc,#pExc{grid-template-columns:repeat(10,minmax(28px,1fr))}}
    @media(max-width:840px){#gInc,#gExc,#pInc,#pExc{grid-template-columns:repeat(9,minmax(28px,1fr))}}
    @media(max-width:720px){
      body::before{filter:brightness(var(--bg-bright)) saturate(.95) blur(.8px)}
      .search{flex-basis:100%;max-width:100%}
      #gInc,#gExc,#pInc,#pExc{grid-template-columns:repeat(9,minmax(26px,1fr));gap:5px}
      #gInc .k,#gExc .k,#pInc .k,#pExc .k{height:32px}
      .counter{font-size:16px;margin:12px 2px 6px}
      .tabs{gap:6px}.tab{padding:5px 8px;font-size:13px}
    }
    @media(max-width:480px){.tab .label{display:none}.tab{padding:5px 6px;font-size:13px}}
	
	th#sort-steps,
    th#sort-entropy,
    th#sort-cands,
    th#sort-bucket { cursor: pointer; }
    th#sort-steps:focus,
    th#sort-entropy:focus,
    th#sort-cands:focus,
    th#sort-bucket:focus { outline: 2px solid #888; outline-offset: 2px; }
	
	/* Button container with flexbox layout */
	.button-container {
		display: flex;
		flex-wrap: wrap;  /* Allow wrapping on small screens */
		gap: 10px;  /* Space between elements */
		align-items: center;  /* Vertically center the elements */
		margin-top: 5px
	}

	/* Label and input field adjustments */
	.button-container label {
		font-size: 13px;
		color: var(--sub);
		gap: 6px;
		align-items: center;
	}

	.button-container input[type="number"] {
		width: 25%; 
		padding: 6px;
		border-radius: 8px;
		border: 1px solid var(--border);
		background: var(--input);
		color: var(--fg);
	}

	/* Button styling */
	button {
		margin: 5px;
	}

	/* Stack label/input fields on one line */
	#button-container-1 {
	  /* width: 10%;  Set labels to take 48% of the width */	
	  margin: 5px 0;  /* Add some vertical spacing between buttons */
	}

		
	/* Ensure buttons are stacked on mobile */
	#button-container-2 {
	  width: 100%;  /* Make buttons take full width */
	}
		

	
	/* add this once */
	.locked {
		pointer-events: none;   /* block mouse/touch */
		opacity: 0.5;           /* subtle visual hint */
	}

	/* Mobile layout: Stack labels*/
	
	@media (min-width: 951px) {
		.filelabel {
		  width: 23%;  	
		  margin-right:10px;		  
		}
		#chooseFileBtn {
		  width: 100%;  	
		}
		#use2309 {
		  width: 23%;  
		}		
		#use3200 {
		  width: 23%;  
		}
		#use14855 {
		  width: 23%;  
		}	

	}		

	@media (max-width: 950px) and (min-width: 481px) {
		.filelabel {
		  width: 46%;  	
		  margin-right:10px;
		}
		#chooseFileBtn {
		  width: 100%;  	
		}
		#use2309 {
		  width: 46%;  
		}		
		#use3200 {
		  width: 46%;  
		}
		#use14855 {
		  width: 46%;  
		}	

	}	
	


	@media (max-width: 480px) {
		.filelabel {
		  width: 97%;  	
		}
		#chooseFileBtn {
		  width: 100%;  	
		}
		#use2309 {
		  width: 100%;  
		}		
		#use3200 {
		  width: 100%;  
		}
		#use14855 {
		  width: 100%;  
		}		
	
	}	
	
	
	.toggle-header {
		cursor: pointer;
		color: #007BFF;
		font-weight: bold;
		margin: 10px 0;
	}

	.toggle-content {
		display: none; /* Hide content initially */
		padding-left: 20px;
		padding-top: 10px;
	}

	.toggle-header:hover {
		text-decoration: underline;
	}

  </style>
 </head>
 <body>
  <div class="wrap">
   <!-- Header -->
   <div class="header-row">
    <h1>
     Wordle Lab
	 <br>
     <span class="tag">
      Advanced Wordle Solver & Analyzer 
     </span>
    </h1>
    <button class="btn" id="modeToggle" title="Toggle Dark/Light">
     üåô Dark
    </button>
   </div>
   <!-- Top controls -->
   <div class="card" style="margin-bottom:12px">
    <div class="bar">
     <label class="filelabel">
      <input accept=".csv,.txt" id="fileInput" type="file"/>
      <button class="btn" id="chooseFileBtn">
       Upload Custom List (CSV)
      </button>
     </label>
     <button class="btn" id="use2309">
      Use 2309 Words (Default)
     </button>
     <button class="btn" id="use3200">
      Use 3200 Words
     </button>
     <button class="btn" id="use14855">
      Use 14855 Words
     </button>
    </div>
    <div class="bar" style="margin-top:10px">
     <div class="search">
      <input id="searchBox" placeholder="Search (use ?, *, [AEIOU], &amp;, |, ( ) &mdash; see help below)" style="text-transform:uppercase; text-transform:uppercase;"/>
     </div>
     <button class="btn" id="clearAll">
      Clear Filters
     </button>
    </div>
   </div>
   <!-- Global include/exclude -->
   <div class="row">
    <div class="card" style="flex:1;min-width:320px">
     <div style="margin-bottom:8px">
      <strong>
       Global Include
      </strong>
     </div>
     <div class="grid" id="gInc">
     </div>
    </div>
    <div class="card" style="flex:1;min-width:320px">
     <div style="margin-bottom:8px">
      <strong>
       Global Exclude
      </strong>
     </div>
     <div class="grid" id="gExc">
     </div>
    </div>
   </div>
   <!-- Position include/exclude -->
   <div class="card" style="margin-top:12px">
    <div class="tabs" id="tabs">
    </div>
    <div class="row" style="margin-top:10px">
     <div class="card" style="flex:1;min-width:280px">
      <div style="margin-bottom:8px">
       <strong>
        Position Include
       </strong>
      </div>
      <div class="grid" id="pInc">
      </div>
     </div>
     <div class="card" style="flex:1;min-width:280px">
      <div style="margin-bottom:8px">
       <strong>
        Position Exclude
       </strong>
      </div>
      <div class="grid" id="pExc">
      </div>
     </div>
    </div>
   </div>
   <!-- Counter -->
   <div class="counter">
    <span id="count">
     0
    </span>
    <small>
     candidates
    </small>
   </div>
   <!-- List -->
   <div class="card list" style="margin-top:6px">
    <ul id="words">
    </ul>
   </div>
   <!-- Recommender -->
   <div class="card" style="margin-top:12px">
    <div class="bar" style="justify-content:space-between">
     <div>
      <strong>
       Next-Guess Recommender
      </strong>
      <span class="tag">
       <!-- (Entropy-based) -->
      </span>
     </div>
    </div>
    <!-- Controls: row 1 -->
    <div class="ctl" style="margin-top:10px">
     <label title="Enforce feedback consistency (Wordle Hard Mode rules)">
      Hard Mode
      <input id="hardMode" type="checkbox">
      </input>
     </label>
     <label title="Guess pool used when Hard Mode is OFF">
      Pool
      <select id="poolSelect">
       <option selected="" value="current">
        Current List
       </option>
       <option value="2309">
        2309 Words
       </option>
       <option value="3200">
        3200 Words
       </option>
       <option value="14855">
        14855 Words
       </option>
      </select>
     </label>
    </div>
    <!-- Controls: row 2 -->
	<div class="button-container">
	  <div id="button-container-1">
		<label title="Cap the number of candidate guesses from the main candidate list">
		Cands Thr
		<input id="exactThreshold" min="1" type="number" value="200"/>
		</label>
		<label title="Cap the number of external guesses from the extended pool (applies only when Hard Mode is OFF)">
		Pool Thr
		<input id="exactMaxPool" min="0" type="number" value="200"/>
		</label>
  	  </div> 
 
	<!-- Buttons placed in the same container -->
	  <div id="button-container-2">
		<button id="suggestExact" class="btn">Suggest</button>
		<button id="stopBtn" class="btn">Stop</button>
		<button id="resetSuggest" class="btn">Reset</button>
	  </div> 
 
	  
	</div>
    <div class="hint" id="modeNote" style="margin-top:4px">
     Hint
    </div> 
    <!-- Progress + status -->
    <div class="progress" style="margin-top:10px">
     <div class="barin" id="pbar">
     </div>
    </div>
    <div class="hint" id="suggestStatus" style="margin-top:8px">
    </div>
    <!-- Table -->
    <div style="overflow:auto;margin-top:8px">
     <table>
      <thead>
       <tr>
        <th>
         Word
        </th>
        <th id="sort-steps" role="button" tabindex="0" title="Click to show the Top 10 by E[steps] (smaller is better)">
         E[steps]
        </th>
        <th id="sort-entropy" role="button" tabindex="0" title="Click to show the Top 10 by Entropy (higher is better)">
         Entropy
        </th>
        <th id="sort-cands" role="button" tabindex="0" title="Click to show the Top 10 by E[cands] (smaller is better)">
         E[cands]
        </th>
        <th id="sort-bucket" role="button" tabindex="0" title="Click to show the Top 10 by Max Bucket (smaller is better)">
         Max Bucket
        </th>
       </tr>
      </thead>
      <tbody id="suggestTable">
      </tbody>
     </table>
    </div>
   </div>
   <!-- Analyze Word -->
   <div class="card" id="analyzeCard" style="margin-top:12px">
    <div class="bar" style="justify-content:space-between; gap:8px;">
     <div>
      <strong>
       Analyze Word
      </strong>
      <span class="tag">
       <!-- (w.r.t. current candidate list) -->
      </span>
     </div>
     <div class="bar" style="gap:6px;">
      <input id="analyzeInput" maxlength="5" placeholder="5-letter word" style="text-transform:uppercase;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:var(--input);color:var(--fg)"/>
      <button class="btn" id="analyzeBtn">
       Analyze
      </button>
     </div>
    </div>
    <div style="overflow:auto;margin-top:10px">
     <table>
      <thead>
       <tr>
        <th>
         Word
        </th>
        <th>
         E[steps]
        </th>
        <th>
         Entropy
        </th>
        <th>
         E[cands]
        </th>
        <th>
         Max Bucket
        </th>
       </tr>
      </thead>
      <tbody id="analyzeTable">
      </tbody>
     </table>
    </div>
   </div>
   <!-- Search Help -->
   <div class="help">
  <strong id="wordListsToggle" class="toggle-header">Word Lists for Wordle</strong>
  <div id="wordListsContent" class="toggle-content">
  <p>Here are three commonly referenced word lists associated with the game Wordle: the ‚Äú2309‚Äù, ‚Äú3200‚Äù, and ‚Äú14855‚Äù word lists. None of these lists have been officially confirmed as the definitive answer sets by the creators of Wordle.</p>
  <ul>
    <li>
      <strong>2309 Word List</strong>: 
      <p>Many players report seeing answers from this 2,309‚Äëword list, though there are exceptions.</p>
    </li>
    <li>
      <strong>3200 Word List</strong>: 
      <p>The 3,200‚Äëword list is often used as a broader ‚Äúanswers‚Äù list in community tools.</p>
    </li>
    <li>
      <strong>14855 Word List</strong>: 
      <p>This much larger list, containing 14,855 words, is believed to reflect the broader vocabulary of words accepted by the game as guesses (rather than necessarily as answers).</p>
    </li>
  </ul>
  <p>Each of these lists plays a different role: the 2309 list as a common answers reference, the 3200 list for extended answer coverage, and the 14855 list for comprehensive guess vocabulary.</p> 
</div>  
<br> 

<strong id="recommenderToggle" class="toggle-header">Next-Guess Recommender Help</strong>
<div id="recommenderContent" class="toggle-content">
<ul>
  <li>
    <b>Next-Guess Recommender</b>: This tool uses an <b>entropy-based</b> approach to narrow down the list of candidate guesses. Initially, it ranks words based on their <b>entropy</b>, which measures the uncertainty or information content of the words. After narrowing down the candidates using entropy, other factors such as <b>E[steps]</b>, <b>E[cands]</b>, and <b>Max Bucket</b> are used to further refine the recommendations.
  </li>
  <li>
    <b>Entropy</b>: A measure of uncertainty, where higher values indicate words with more potential for narrowing down the solution space. Entropy values are <b>accurate</b> and represent how "informative" a word is when used as a guess.
  </li> 
  <li>
    <b>E[steps]</b>: An estimate of the number of steps required to guess the target word, given the current pool of candidate words. This is an approximation and may not always be 100% accurate.
  </li>  
  <li>
    <b>E[cands]</b>: The expected number of candidates remaining after a guess, based on the current word pool. This metric is <b>accurate</b> and helps assess how effective a guess is in reducing the search space.
  </li>  
  <li>
    <b>Max Bucket</b>: The size of the largest group of words that would result from guessing a particular word, given the current state of the game. This value is <b>accurate</b> and helps identify words that will divide the remaining possibilities evenly.
  </li>  
<br>  
  <li>
    <b>Hard Mode ON</b>: Guesses are made only from the top-ranked (Cands Thr) candidates based on entropy.
  </li>
  <li>
    <b>Hard Mode OFF</b>: Guesses are made from both the top-ranked (Cands Thr) candidates and top-ranked words from the external pool (Pool Thr), based on entropy.
  </li>
  <li>
    <b>Cands Thr (Candidates Threshold)</b>: The maximum number of top-ranked candidate guesses from the main candidate list, selected based on entropy, used for the recommendation.
  </li>
  <li>
    <b>Pool Thr (Pool Threshold)</b>: The maximum number of top-ranked external pool guesses, selected based on entropy, used for the recommendation (only applies when Hard Mode is OFF).
  </li>
</ul>
</div>
<br>
    <strong id="searchHelpToggle" class="toggle-header">Search Help</strong>
	<div id="searchHelpContent" class="toggle-content">
    <ul>
     <li><b>?</b>: exactly one letter (e.g.,<code>A?E</code>&rarr;<i>ACE, APE, ARE</i>)
     </li>
     <li><b>*</b>: zero or more letters (e.g.,<code>E*E</code>&rarr;<i>AGREE, EAGLE, EERIE</i>)
     </li>
     <li><b>[AEIOU]</b>: any one listed; <b>[^AEIOU]</b>: not these (e.g.,<code>[^AEIOU]ATE</code>&rarr;<i>SLATE, CRATE</i>)
     </li>
     <li><b>&amp;</b>: AND; <b>|</b>: OR (AND has higher precedence)
     </li>
     <li><b>( )</b>: group terms (e.g.,<code>(ING &amp; R) | (A?E &amp; N)</code>)
     </li>
    </ul>
	</div>
    <!-- Keyboard hints -->
	<br>
	<strong id="keyboardHintsToggle" class="toggle-header">Shortcut Keys</strong>
    <div id="keyboardHintsContent" class="toggle-content">
	<ul>
	 <li><b>Letter</b>: Global Include
	 </li>
	 <li><b>Alt+Letter</b>: Global Exclude
	 </li>
	 <li><b>Shift+Letter</b>: Position Include
	 </li>
	 <li><b>Ctrl+Letter</b>: Position Exclude
	 </li>	
	 <li><b>1&ndash;5</b>: Switch Tab
	 </li>	
	 <li><b>/</b>: Search
	 </li>	
	 <li><b>@</b>: Analyze Word
	 </li>		 
	 <li><b>`</b>: Theme
	 </li>		 
	</ul>
    </div>
   </div>
  </div>
  <script>
document.addEventListener("DOMContentLoaded", function() {
  // Function to toggle content visibility
  function toggleContent(sectionId) {
    const content = document.getElementById(sectionId);
    if (content.style.display === "none" || content.style.display === "") {
      content.style.display = "block"; // Show content
    } else {
      content.style.display = "none"; // Hide content
    }
  }

  // Add event listeners to each section header
  document.getElementById("wordListsToggle").addEventListener("click", function() {
    toggleContent("wordListsContent");
  });

  document.getElementById("recommenderToggle").addEventListener("click", function() {
    toggleContent("recommenderContent");
  });

  document.getElementById("searchHelpToggle").addEventListener("click", function() {
    toggleContent("searchHelpContent");
  });
  
  document.getElementById("keyboardHintsToggle").addEventListener("click", function() {
    toggleContent("keyboardHintsContent");
  });  
});
  
  
   /* ===== Utilities & State ===== */
    const byId=id=>document.getElementById(id);
    const ALPHA=Array.from({length:26},(_,i)=>String.fromCharCode(65+i));
    const state={
      all:[], filtered:[], search:'',
      searchTester:null,
      globalInclude:new Set(), globalExclude:new Set(),
      pos:Array.from({length:5},()=>({include:new Set(),exclude:new Set()})),
      activePos:0,
      base2309:[], base3200:[], base14855:[],
      cancel:false
    };

    /* ===== Theme ===== */
    (function(){
      const s=localStorage.getItem('wf-theme');
      if(s==='light')document.body.classList.add('light');
      updateThemeBtn(); byId('modeToggle').onclick=toggleTheme;
    })();
    function toggleTheme(){
      document.body.classList.toggle('light');
      localStorage.setItem('wf-theme',document.body.classList.contains('light')?'light':'dark');
      updateThemeBtn();
    }
    function updateThemeBtn(){
      byId('modeToggle').textContent=document.body.classList.contains('light')?'‚òÄÔ∏è Light':'üåô Dark';
    }

    /* ===== CSV parsing & loading ===== */
    function parseWordsFromCsvText(t){
      const lines=t.split(/\r?\n/);const words=[];const seen=new Set();
      for(const raw of lines){
        const line=raw.trim(); if(!line) continue;
        const cells=line.split(/,|\s+/);
        for(let c of cells){
          c=(c||'').trim().toLowerCase();
          if(/^[a-z]{5}$/.test(c)&&!seen.has(c)){ seen.add(c); words.push(c); }
        }
      }
      return words;
    }
    async function fetchCsv(name){
      const res=await fetch(`./${name}`,{cache:'no-store'});
      if(!res.ok) throw new Error('fetch failed: '+name);
      return parseWordsFromCsvText(await res.text());
    }
    async function loadCsvFile(name){
      try{
        lockUI(true);
        const words=await fetchCsv(name);
        loadWordsFromArray(words);
      }catch(e){ alert('Error loading '+name+': '+e.message); }
      finally{ lockUI(false); }
    }

    /* ===== Keyboards & Tabs ===== */
    function buildKeyboard(container,kind){
      container.innerHTML='';
      for(const ch of ALPHA){
        const d=document.createElement('div');
        d.className='k'; d.textContent=ch; d.dataset.ch=ch.toLowerCase();
        d.onclick=()=>{
          if(kind==='gInc')toggle(state.globalInclude,state.globalExclude,d.dataset.ch);
          else if(kind==='gExc')toggle(state.globalExclude,state.globalInclude,d.dataset.ch);
          else if(kind==='pInc')toggle(state.pos[state.activePos].include,state.pos[state.activePos].exclude,d.dataset.ch);
          else toggle(state.pos[state.activePos].exclude,state.pos[state.activePos].include,d.dataset.ch);
          refresh(); apply();
        };
        container.appendChild(d);
      }
    }
    function toggle(primary,secondary,ch){
      if(primary.has(ch)) primary.delete(ch); else { primary.add(ch); secondary.delete(ch); }
    }
    function refresh(){
      const gI=byId('gInc').children, gE=byId('gExc').children,
            pI=byId('pInc').children, pE=byId('pExc').children;
      for(const e of gI) e.classList.toggle('inc',state.globalInclude.has(e.dataset.ch));
      for(const e of gE) e.classList.toggle('exc',state.globalExclude.has(e.dataset.ch));
      for(const e of pI) e.classList.toggle('inc',state.pos[state.activePos].include.has(e.dataset.ch));
      for(const e of pE) e.classList.toggle('exc',state.pos[state.activePos].exclude.has(e.dataset.ch));
      for(const t of byId('tabs').children) t.classList.toggle('active',Number(t.dataset.idx)===state.activePos);
    }
    function renderTabs(){
      const tabs=byId('tabs'); tabs.innerHTML='';
      for(let i=0;i<5;i++){
        const b=document.createElement('button');
        b.className='tab'+(i===state.activePos?' active':'');
        b.innerHTML='<span class="label">Pos </span><span class="num">'+(i+1)+'</span>';
        b.dataset.idx=i; b.onclick=()=>{ state.activePos=i; refresh(); };
        tabs.appendChild(b);
      }
    }

    /* ===== Search expression ===== */
    function sanitizeClassContent(s){const x=s.toLowerCase().replace(/\s+/g,''); if(!/^[a-z\-\^]*$/.test(x)) return null; return x;}
    function escapeRe(s){return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');}
    function buildRegexFromMiniPattern(q){
      let reStr=''; for(let i=0;i<q.length;i++){ const ch=q[i];
        if(ch==='*'){ let j=i; while(j<q.length&&q[j]==='*') j++; reStr+='[a-z]*'; i=j-1; }
        else if(ch==='?'){ reStr+='[a-z]'; }
        else if(ch==='['){ let j=i+1; while(j<q.length&&q[j]!==']') j++;
          if(j<q.length){ const s=q.slice(i+1,j); const ok=sanitizeClassContent(s); if(ok!==null){reStr+=`[${ok}]`; i=j; } else reStr+='\\['; }
          else reStr+='\\[';
        } else if(ch===' '){ /* ignore */ }
        else if(/[a-z]/.test(ch)){ reStr+=ch; }
        else reStr+=escapeRe(ch);
      }
      return new RegExp(reStr);
    }
    function tokenize(expr){
      const s=(expr||'').toLowerCase(); const out=[]; let i=0; const isOp=c=>c==='|'||c==='&';
      while(i<s.length){
        const c=s[i]; if(c===' '){i++;continue;}
        if(c==='('||c===')'||isOp(c)){ out.push({type:c}); i++; continue; }
        let buf=''; while(i<s.length){ const ch=s[i];
          if(ch==='('||ch===')'||isOp(ch)||ch===' ') break;
          if(ch==='['){ let j=i+1; while(j<s.length&&s[j]!==']') j++; if(j<s.length){ buf+=s.slice(i,j+1); i=j+1; continue; } else { buf+='['; i++; continue; } }
          buf+=ch; i++;
        } out.push({type:'pat',value:buf});
      } return out;
    }
    function toRPN(tokens){
      const out=[], st=[]; const prec=t=>t.type==='&'?2:(t.type==='|'?1:0); const isOp=t=>t.type==='|'||t.type==='&';
      for(const t of tokens){
        if(t.type==='pat') out.push(t);
        else if(isOp(t)){ while(st.length){ const top=st[st.length-1]; if(isOp(top)&&prec(top)>=prec(t)) out.push(st.pop()); else break; } st.push(t); }
        else if(t.type==='(') st.push(t);
        else if(t.type===')'){ while(st.length&&st[st.length-1].type!=='(') out.push(st.pop()); if(st.length&&st[st.length-1].type==='(') st.pop(); }
      }
      while(st.length){ const x=st.pop(); if(x.type!=='('&&x.type!==')') out.push(x); } return out;
    }
    function buildTesterFromRPN(rpn){
      const st=[]; for(const t of rpn){
        if(t.type==='pat'){ const re=buildRegexFromMiniPattern(t.value); st.push(w=>re.test(w)); }
        else if(t.type==='&'||t.type==='|'){ const b=st.pop(), a=st.pop(); if(!a||!b) return null; st.push(t.type==='&'?(w)=>a(w)&&b(w):(w)=>a(w)||b(w)); }
      }
      return st.length===1?st[0]:null;
    }
    function buildSearchTester(expr){
       const toks=tokenize(expr); if(!toks.some(t=>t.type==='pat')) return null;
       const rpn=toRPN(toks); const tester=buildTesterFromRPN(rpn); return tester||null;
    }

    /* ===== Filter & list ===== */
    function apply(){
      const out=[]; const gi=state.globalInclude, ge=state.globalExclude; const tester=state.searchTester;
      WORDS: for(const w of state.all){
        if(tester && !tester(w)) continue;
        for(const ch of ge) if(w.includes(ch)) continue WORDS;
        for(const ch of gi) if(!w.includes(ch)) continue WORDS;
        for(let i=0;i<5;i++){
          const need=state.pos[i].include, ban=state.pos[i].exclude, c=w[i];
          if(need.size>0 && !need.has(c)) continue WORDS;
          if(ban.has(c)) continue WORDS;
        }
        out.push(w);
      }
      state.filtered=out; renderList();
    }
    function renderList(){
      const ul=byId('words'); ul.innerHTML='';
      for(const w of state.filtered){ const li=document.createElement('li'); li.textContent=w.toUpperCase(); ul.appendChild(li); }
      byId('count').textContent=state.filtered.length;
    }
    function loadWordsFromArray(a){
      const seen=new Set(); state.all=a.filter(w=>/^[a-z]{5}$/.test(w)&&!seen.has(w)&&seen.add(w)).sort(); apply();
    }

    /* ===== Wordle feedback ===== */
    function pattern(guess, answer){
      const g=[...guess], a=[...answer]; const res=Array(5).fill('0'); const cnt={};
      for(let i=0;i<5;i++){ if(a[i]===g[i]){ res[i]='2'; } else { cnt[a[i]]=(cnt[a[i]]||0)+1; } }
      for(let i=0;i<5;i++){ if(res[i]==='2') continue; const ch=g[i]; if(cnt[ch]>0){ res[i]='1'; cnt[ch]--; } }
      return res.join('');
    }
    function partitionByPattern(S, guess){
      const map=new Map();
      for(const ans of S){
        const p=pattern(guess, ans);
        let arr=map.get(p); if(!arr){ arr=[]; map.set(p,arr); }
        arr.push(ans);
      }
      return map;
    }
    function entropyAndExpectedSize(S, guess){
      const parts=partitionByPattern(S, guess); const n=S.length; let H=0, exp=0, maxb=0;
      for(const arr of parts.values()){
        const p=arr.length/n; H += -p*Math.log2(p); exp += p*arr.length; if(arr.length>maxb) maxb=arr.length;
      }
      return {entropy:H, expected:exp, maxBucket:maxb};
    }

    /* ===== External pools (lazy load) ===== */
    async function ensurePoolLoaded(which){
      if(which==='2309' && !state.base2309.length){ state.base2309 = await fetchCsv('wordle_solutions_2309.csv'); }
      if(which==='3200' && !state.base3200.length){ state.base3200 = await fetchCsv('wordle_solutions_3200.csv'); }
      if(which==='14855'&& !state.base14855.length){ state.base14855= await fetchCsv('wordle_solutions_14855.csv'); }
    }
    async function getExternalPool(){
      const sel=byId('poolSelect').value;
      if(sel==='current') return state.all;        // current loaded list
      await ensurePoolLoaded(sel);
      if(sel==='2309')  return state.base2309.length? state.base2309 : state.all;
      if(sel==='3200')  return state.base3200.length? state.base3200 : state.all;
      if(sel==='14855') return state.base14855.length? state.base14855: state.all;
      return state.all;
    }

	let uiLocked = false; // when true, block keyboard shortcuts during calculation

    /* ===== Recommenders ===== */
    function lockUI(yes){
	  uiLocked = yes; // <-- add this line
	  // 1) Buttons: disable everything except Stop
      document.querySelectorAll('.btn').forEach(b => {
	    if (b.id !== 'stopBtn') b.disabled = yes; // Disable all buttons except the Stop button
      });
	  const stop = byId('stopBtn');
	  if (stop) stop.disabled = !yes;  // Stop stays enabled during calculation
	  
	  // 2) Inputs/toggles to freeze while computing
	  ['hardMode','exactThreshold','exactMaxPool','poolSelect','analyzeInput'].forEach(id=>{
	    const el = byId(id);
		if (el) el.disabled = yes;
	  });
	  
	  // 3) Mouse clicks off for the letter keyboards only
	  //    (these are your on-screen grids)
	  ['gInc','gExc','pInc','pExc'].forEach(id=>{
	    const el = byId(id);
		if (el) el.classList.toggle('locked', yes);
	  });
	  
	  // 4) Keyboard events off while computing (except Stop click which is mouse)
	  // window.onkeydown = yes ? (e) => e.preventDefault() : originalKeyDown;
    }
    function setProgress(p){ byId('pbar').style.width = Math.max(0,Math.min(100,p))+'%'; }

    function resetSuggestions(){
      byId('suggestTable').innerHTML='';
      byId('suggestStatus').textContent='';
      setProgress(0);
      state.cancel=false;
	  
	  // Reset the data variables
	  lastSuggestRows = []; // Clear previous results
	  
	  // Optionally, reset other relevant states or settings (e.g., inputs, settings)
	  const inputs = document.querySelectorAll('input[type="number"]');
	  inputs.forEach(input => {
	    input.value = input.defaultValue; // Reset to the original value (if you have default values)
	  });
	  
	  // You can add more resets if needed (e.g., graphs, charts, etc.)
	  
	  // Provide feedback to the user
	  byId('suggestStatus').textContent = 'Results have been reset.';
	  
    }


// Build a capped guess pool: top-K from S + top-N from external (by cheap pre-score)
async function buildGuessPoolCapped(S) {
  const hard = byId('hardMode').checked;
  const n = S.length;
  
  // Hard Mode On: Search Cands Thr by Entropy
  if (hard) {
    const candsThr = Math.max(1, Number(byId('exactThreshold').value) || n);
    const scoredS = [];

    for (const g of S) {
      const met = entropyAndExpectedSize(S, g);
      scoredS.push({ g, score: met.entropy, expected: met.expected });
    }

    scoredS.sort((a, b) => (b.score - a.score) || (a.expected - b.expected));

    const topS = scoredS.slice(0, Math.min(candsThr, scoredS.length)).map(x => x.g);
    return topS;
  }

  // Hard Mode Off
  const ext = await getExternalPool();

  if (!ext || ext.length === 0) {
    console.warn("No external pool found, proceeding with only filtered candidates.");
  }

  const K = Math.max(1, Number(byId('exactThreshold').value) || S.length); // Cands Thr
  const N = Math.max(0, Number(byId('exactMaxPool').value) || 0);        // Pool Thr

  // Cheap metric (NOT exact E[steps]): entropy + tie-break by expected size
  function cheapScoreFor(word, set) {
    const met = entropyAndExpectedSize(set, word);
    return { score: met.entropy, expected: met.expected };
  }

  // --- Rank S by cheap score, keep top-K ---
  const scoredS = [];
  for (const g of S) {
    const { score, expected } = cheapScoreFor(g, S);
    scoredS.push({ g, score, expected });
  }
  scoredS.sort((a, b) => (b.score - a.score) || (a.expected - b.expected));
  const topS = scoredS.slice(0, Math.min(K, scoredS.length)).map(x => x.g);

  // --- Rank external by cheap score against S, keep top-N ---
  const baseSet = new Set(S);
  const scoredExt = [];
  if (N > 0) {
    for (const g of ext) {
      if (baseSet.has(g)) continue;
      const { score, expected } = cheapScoreFor(g, S);
      scoredExt.push({ g, score, expected });
    }
    scoredExt.sort((a, b) => (b.score - a.score) || (a.expected - b.expected));
  }
  const topExt = (N > 0) ? scoredExt.slice(0, Math.min(N, scoredExt.length)).map(x => x.g) : [];

  // Final capped pool = top-K from S + top-N from external
  return [...topS, ...topExt];
}





// One-lookahead exact E[steps] using the local partitionByPattern(S, guess).
// Returns expected steps INCLUDING the current guess g.
function exactEstepsOneLookaheadLocal(S, g) {
  const n = S.length;
  const parts = partitionByPattern(S, g);
  let est = 0;

  for (const [pat, arr] of parts.entries()) {
    const p = arr.length / n;

    if (pat === '22222') {
      // Solved now: takes 1 step (this guess)
      est += p * 1;
    } else {
      // Choose best next guess g2 inside arr, then approximate the leaf.
      let best = Infinity;
      for (const g2 of arr) {
        const parts2 = partitionByPattern(arr, g2);
        let e2 = 0;
        for (const [pat2, arr2] of parts2.entries()) {
          const p2 = arr2.length / arr.length;
          if (pat2 === '22222') {
            e2 += p2 * 1; // solved next step
          } else {
            const expLeaf = (arr2.length === 1) ? 1 : 2; // tiny leaf heuristic
            e2 += p2 * (1 + expLeaf); // 1 for taking g2, plus leaf
          }
        }
        if (e2 < best) best = e2;
      }
      est += p * (1 + best); // 1 for taking g now, plus best subtree
    }
  }
  return est;
}

/* ===== Suggest Exact (no Fast fallback) ===== */
async function suggestExact(){
  const S = [...state.filtered];
  const n = S.length;
  const tb = byId('suggestTable'), status = byId('suggestStatus');
  tb.innerHTML=''; setProgress(0); state.cancel=false; 

  if(n===0){ status.textContent='No candidates.'; return; }

  lockUI(true);
  try {
  
  await new Promise(r=>setTimeout(r,10));

  // NEW: capped pool (top-K from S + top-N from external)
  const pool = await buildGuessPoolCapped(S);
  const total = pool.length;
  
  const hard = byId('hardMode').checked;
  if (hard) {
    const candsThr = Math.max(1, Math.min(Number(byId('exactThreshold').value) || n, n));
    status.textContent = `Evaluating top ${candsThr} words (from filtered candidates) ...`;
  } else {
    status.textContent = `Evaluating top ${total} words (from filtered candidates and external pool) ...`;
  }
  
  const rows=[]; let evaluated=0;

  for(let i=0;i<pool.length;i++){
    if(state.cancel) break;
    const g = pool[i];

    // NEW: compute expected steps with the local one-lookahead (includes current turn)
    const exp = exactEstepsOneLookaheadLocal(S, g);

    const met = entropyAndExpectedSize(S, g);
    rows.push({ word:g, esteps:exp, entropy:met.entropy, expected:met.expected, maxBucket:met.maxBucket });
    evaluated++;
    if((i&3)===0){ setProgress(100*evaluated/total); await new Promise(r=>setTimeout(r,0)); }
  }

  rows.sort((a,b)=> (a.esteps - b.esteps) || (b.entropy - a.entropy) || (a.expected - b.expected));
  lastSuggestRows = rows;
  lastSuggestLabel = `by Estimated E[steps]`;
  renderSuggestRows(rows, lastSuggestLabel);
  
  } finally {

  lockUI(false); setProgress(100);
  }
}


    function renderSuggestRows(rows, label){
      const tb=byId('suggestTable'); const status=byId('suggestStatus');
      status.textContent = `Top 10 Words ${label}`;
      tb.innerHTML='';
      for(const r of rows.slice(0,10)){
        const tr=document.createElement('tr');
        tr.innerHTML = `
          <td class="mono">${r.word.toUpperCase()}</td>
          <td>${isFinite(r.esteps)? r.esteps.toFixed(3) : '‚Äî'}</td>
          <td>${r.entropy?.toFixed(3) ?? '‚Äî'}</td>
          <td>${r.expected?.toFixed(1) ?? '‚Äî'}</td>
          <td>${r.maxBucket ?? '‚Äî'}</td>
        `;
        tb.appendChild(tr);
      }
    }

// ===== Single-direction sorting for the suggestion table =====

// Cache the latest suggestion rows and their label so we can re-render on header clicks
let lastSuggestRows = [];
let lastSuggestLabel = "";

/**
 * Always-sort-best-first policy (no toggle):
 * - steps: ascending (smaller E[steps] is better)
 * - entropy: descending (larger entropy is better)
 * - expected (E[cands]): ascending (smaller is better)
 * - maxBucket: ascending (smaller is better)
 */
function sortRowsOneWay(rows, key) {
  const copy = rows.slice();

  // Pull helpers
  const num = (v) => (typeof v === "number" ? v : Number(v));
  const stepsValue = (r) => {
    // Treat NaN (no E[steps], e.g., Fast rows) as +Infinity so they go to the bottom
    const v = num(r.esteps);
    return Number.isFinite(v) ? v : Number.POSITIVE_INFINITY;
  };

  copy.sort((a, b) => {
    if (key === "esteps") {
      return stepsValue(a) - stepsValue(b);                 // ASC
    } else if (key === "entropy") {
      return num(b.entropy) - num(a.entropy);               // DESC
    } else if (key === "expected") {
      return num(a.expected) - num(b.expected);             // ASC
    } else if (key === "maxBucket") {
      return num(a.maxBucket) - num(b.maxBucket);           // ASC
    }
    return 0;
  });

  return copy;
}

/**
 * Re-render from cache using a single sort key.
 * Does nothing if there is no cached result yet.
 */
function resortSuggestTableBy(key) {
  if (!lastSuggestRows.length) return;
  
  // Sort rows based on the selected key (E[steps], entropy, etc.)
  const sorted = sortRowsOneWay(lastSuggestRows, key);
  const nice =
    key === "esteps" ? "Estimated E[steps]" :
    key === "entropy" ? "Entropy" :
    key === "expected" ? "E[cands]" :
    key === "maxBucket" ? "Max Bucket" : key;
  renderSuggestRows(sorted, `by ${nice}`);
}

    /* ===== Mode wiring (Hard ‚Üî Pool) ===== */
    function syncModeControls(){
      const hard = byId('hardMode').checked;
      byId('poolSelect').disabled = hard;
      byId('modeNote').textContent = hard
        ? 'Hard Mode ON'
        : 'Hard Mode OFF';
    }

    /* ===== Wire events ===== */
	
	// let originalKeyDown; // Declare globally
	
    function wire(){
      buildKeyboard(byId('gInc'),'gInc');
      buildKeyboard(byId('gExc'),'gExc');
      buildKeyboard(byId('pInc'),'pInc');
      buildKeyboard(byId('pExc'),'pExc');
      renderTabs(); refresh();

      byId('searchBox').oninput=e=>{
        state.search=e.target.value;
        state.searchTester=buildSearchTester(state.search);
        apply();
      };

      byId('clearAll').onclick=()=>{
        state.globalInclude.clear(); state.globalExclude.clear();
        for(let i=0;i<5;i++){ state.pos[i].include.clear(); state.pos[i].exclude.clear(); }
        state.search=''; state.searchTester=null; byId('searchBox').value='';
        refresh(); apply();
      };

      const f=byId('fileInput');
      byId('chooseFileBtn').onclick=()=>f.click();
      f.onchange=async()=>{
        const file=f.files?.[0]; if(!file) return;
        try{
          const t=await file.text(); const w=parseWordsFromCsvText(t);
          if(!w.length) throw new Error('empty'); loadWordsFromArray(w);
        }catch(e){ alert('Load failed: '+e.message); }
        f.value='';
      };

      byId('use2309').onclick=()=>loadCsvFile('wordle_solutions_2309.csv');
      byId('use3200').onclick=()=>loadCsvFile('wordle_solutions_3200.csv');
      byId('use14855').onclick=()=>loadCsvFile('wordle_solutions_14855.csv');

      const btnFast  = byId('suggestFast');
	  const btnExact = byId('suggestExact');
	  
	  if (btnFast)  btnFast.onclick  = () => suggestFast();
	  if (btnExact) btnExact.onclick = () => suggestExact();

      byId('resetSuggest').onclick=resetSuggestions;
      byId('stopBtn').onclick=()=>{ state.cancel=true; byId('suggestStatus').textContent+=' (stopping‚Ä¶)'; };

      byId('hardMode').onchange=syncModeControls;
      byId('poolSelect').onchange=()=>{}; // no-op
      syncModeControls();
	  
	  // Original keydown event handler (before lockUI was triggered)
	  // originalKeyDown = window.onkeydown;

      window.onkeydown = (e) => {
	    if (uiLocked) { e.preventDefault(); return; } // block during calculation
		
        if(document.activeElement === byId('searchBox')) return;
        const k = e.key, l = k.toLowerCase();
        if(l >= '1' && l <= '5') {
		  state.activePos = Number(l) - 1;
		  refresh(); return;		
		}
        if(k === '/') {
		  e.preventDefault();
		  byId('searchBox').focus();
		  return;
		}
        if(k === '@') {
		  e.preventDefault();
		  byId('analyzeInput').focus();
		  return;
		}		
        if(k === '`') {
		  toggleTheme();
		  return;
		}
        if(!/^[a-z]$/i.test(l)) return;
        if(e.ctrlKey || e.metaKey) {
		  toggle(state.pos[state.activePos].exclude, state.pos[state.activePos].include, l);
		} else if(e.altKey) {
		  toggle(state.globalExclude, state.globalInclude, l);
        } else if(e.shiftKey) {
		  toggle(state.pos[state.activePos].include, state.pos[state.activePos].exclude, l);
        } else {
		  toggle(state.globalInclude, state.globalExclude, l);
        }
        refresh();
		apply();
      };
    }

    /* ===== Boot ===== */
document.addEventListener('DOMContentLoaded', async function(){
  wire();  
  try{
    const base = await fetchCsv('wordle_solutions_2309.csv');
    state.base2309 = base.slice();
    loadWordsFromArray(base);
  }catch(e){
    console.error(e);
  }
});
  </script>
  <script>
   // === Analyze Word Logic ===
(function(){
  function getCandidates(){
    try{
      if (window.state && Array.isArray(window.state.filtered) && window.state.filtered.length){
        return window.state.filtered.slice();
      }
      if (window.state && Array.isArray(window.state.all) && window.state.all.length){
        return window.state.all.slice();
      }
    }catch(e){}
    var lis = Array.from(document.querySelectorAll('#words li'));
    if(lis.length) return lis.map(li=>li.textContent.trim().toLowerCase()).filter(w=>/^[a-z]{5}$/.test(w));
    return [];
  }

  function patternFor(guess, target){
    const g = guess.split(''); const t = target.split('');
    const res = Array(5).fill(0); const used = Array(5).fill(false);
    for(let i=0;i<5;i++){ if(g[i]===t[i]){ res[i]=2; used[i]=true; } }
    for(let i=0;i<5;i++){
      if(res[i]===2) continue;
      const ch = g[i];
      for(let j=0;j<5;j++){ if(!used[j] && t[j]===ch){ res[i]=1; used[j]=true; break; } }
    }
    return res.join('');
  }

  function partitionByPattern(guess, set){
    const map = new Map();
    for(const w of set){
      const p = patternFor(guess, w);
      const arr = map.get(p); if(arr) arr.push(w); else map.set(p, [w]);
    }
    return map;
  }

  function entropyOf(guess, set){
    const map = partitionByPattern(guess, set);
    const N = set.length; let H = 0; let maxb = 0; let expSize = 0;
    for(const arr of map.values()){
      const m = arr.length; const p = m / N; maxb = Math.max(maxb, m);
      if(p>0){ H += -p * Math.log2(p); }
      expSize += m*m / N;
    }
    return {entropy:H, expected:expSize, maxBucket:maxb, buckets:map};
  }

	/* ===== Exact Esteps One Lookahead function ===== */
  function exactEstepsOneLookahead(guess, set){
    const part = partitionByPattern(guess, set);
    const N = set.length;
    let est = 0;
    for (const [pat, subset] of part.entries()){
      const m = subset.length; const p = m/N;
      if (pat === '22222'){ est += p * 1; }  // No extra steps for exact match
      else {
        let best = Infinity;
        for (const g2 of subset){
          const part2 = partitionByPattern(g2, subset);
          let e2 = 0;
          for (const [pat2, subset2] of part2.entries()){
            const m2 = subset2.length; const p2 = m2/subset.length;
            if (pat2 === '22222') e2 += p2 * 1;  // Exact match adds 0 steps
            else {
              const expLeaf = (m2===1) ? 1 : 2; // If subset is single, 1 step; else, 2 steps
              e2 += p2 * (1 + expLeaf); // 1 for the current guess, plus expected leaf steps
            }
          }
          if (e2 < best) best = e2;
        }
        est += p * (1 + best);
      }
    }
    return est;
  }

  function analyzeWord(word, set, exactThr){
    word = (word||'').toLowerCase();
    if(!/^[a-z]{5}$/.test(word)) return {error:'Please enter a 5-letter word (A‚ÄìZ).'};
    if(!set || !set.length) return {error:'No candidates loaded.'};
    const fast = entropyOf(word, set);
    let esteps = null;
    try{ esteps = exactEstepsOneLookahead(word, set); }catch(e){ esteps = null; }
    return { word, esteps, entropy:fast.entropy, expected:fast.expected, maxBucket:fast.maxBucket };
  }

  function renderAnalyzeRow(result){
    const tbody = document.getElementById('analyzeTable');
    if(!tbody) return;
    tbody.innerHTML = '';
    if(result.error){
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 5; td.textContent = result.error;
      tr.appendChild(td); tbody.appendChild(tr); return;
    }
    const tr = document.createElement('tr');
    const fmt = (x)=> (x==null? '‚Äî' : (Math.round(x*1000)/1000));
    const cells = [
      result.word.toUpperCase(),
      (result.esteps==null? '‚Äî' : fmt(result.esteps)),
      fmt(result.entropy),
      fmt(result.expected),
      String(result.maxBucket)
    ];
    for(const v of cells){ const td=document.createElement('td'); td.textContent=v; tr.appendChild(td); }
    tbody.appendChild(tr);
  }

  function onAnalyze(){
    const thrEl = document.getElementById('exactThreshold');
	const maxValue = state.filtered.length;
    const thr = thrEl ? Math.max(5, Math.min(maxValue, parseInt(thrEl.value||'400',10))) : 400;
    const set = getCandidates();
    const val = (document.getElementById('analyzeInput').value||'').trim();
    renderAnalyzeRow(analyzeWord(val, set, thr));
  }

  document.addEventListener('DOMContentLoaded', function(){
    const btn = document.getElementById('analyzeBtn');
    const ipt = document.getElementById('analyzeInput');
    if(btn) btn.addEventListener('click', onAnalyze);
    if(ipt){
      ['keydown','keypress','keyup'].forEach(ev=>ipt.addEventListener(ev, e=>e.stopPropagation()));
      ipt.addEventListener('keydown', (e)=>{ if(e.key==='Enter') onAnalyze(); });
    }
  });
})();

document.addEventListener("DOMContentLoaded", () => {
  const hSteps   = document.getElementById("sort-steps");
  const hEntropy = document.getElementById("sort-entropy");
  const hCands   = document.getElementById("sort-cands");
  const hBucket  = document.getElementById("sort-bucket");

  if (hSteps)   hSteps.addEventListener("click",   () => resortSuggestTableBy("esteps"));
  if (hEntropy) hEntropy.addEventListener("click", () => resortSuggestTableBy("entropy"));
  if (hCands)   hCands.addEventListener("click",   () => resortSuggestTableBy("expected"));
  if (hBucket)  hBucket.addEventListener("click",  () => resortSuggestTableBy("maxBucket"));
});

// === Global hotkey guard: ignore when typing in inputs/textareas/contenteditable ===
(function(){
  const addGuard = (handler) => function(e){
    const t = (e.target || document.activeElement);
    const tag = (t && t.tagName || '').toLowerCase();
    if (tag === 'input' || tag === 'textarea' || (t && t.isContentEditable)) return;
    return handler.call(this, e);
  };
  // Patch document keydown listeners if code uses a single handler pattern
  // If your app attaches like: document.addEventListener('keydown', fn)
  // you can rebind here by removing and re-adding. Otherwise, rely on local stopPropagation above.
})();
  </script>
  <script id="searchBoxUpperHook">
   document.addEventListener('DOMContentLoaded', function(){
  var sb = document.getElementById('searchBox');
  if (sb) {
    sb.addEventListener('input', function(){
      var p = sb.selectionStart;
      sb.value = sb.value.toUpperCase();
      try { sb.setSelectionRange(p, p); } catch(e){}
    });
  }
});
  </script>
 </body>
</html>
