<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Wordle Lab ‚Äì Ultimate Wordle Solver & Analyzer</title>
	<meta name="description" content="Wordle Lab is an ultimate Wordle solver and entropy-based analyzer with Basic and Advanced modes.">
	<meta name="keywords" content="Wordle, Wordle Lab, Wordle Solver, Wordle Helper, Wordle Analyzer, Wordle Strategy, Entropy, E[steps], E[cands], Max Bucket, Next Guess Recommender, Hard Mode, Basic Mode, Advanced Mode">
	<meta name="author" content="Jaehong Kim">
	<meta name="robots" content="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1">
	<meta name="theme-color" content="#0f1115">
	
	<!-- Open Graph (for Facebook, LinkedIn, etc.) -->
	<meta property="og:title" content="Wordle Lab ‚Äì Ultimate Wordle Solver & Analyzer">
	<meta property="og:description" content="Wordle Lab is an ultimate Wordle solver and entropy-based analyzer with Basic and Advanced modes.">
	<meta property="og:url" content="https://wordlelab.com/">
	<meta property="og:type" content="website">
	<meta property="og:image" content="https://wordlelab.com/preview.png">
	
	<!-- Twitter Card -->
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="Wordle Lab ‚Äì Ultimate Wordle Solver & Analyzer">
	<meta name="twitter:description" content="Wordle Lab is an ultimate Wordle solver and entropy-based analyzer with Basic and Advanced modes.">
	<meta name="twitter:image" content="https://wordlelab.com/preview.png">
	<meta name="twitter:site" content="@DrDrTwice">
	
	<!-- Canonical URL -->
	<link rel="canonical" href="https://wordlelab.com/">
	
	<!-- Favicons & PWA -->
	<link href="./apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180">
	<link href="./favicon-32x32.png" rel="icon" sizes="32x32" type="image/png">
	<link href="./favicon-16x16.png" rel="icon" sizes="16x16" type="image/png">
	<link href="./site.webmanifest" rel="manifest">
	
	<!-- ===== Structured Data (JSON-LD) ===== -->
	<script type="application/ld+json">
	{
	  "@context": "https://schema.org",
	  "@type": "WebSite",
	  "name": "Wordle Lab",
	  "url": "https://wordlelab.com/",
	  "applicationCategory": "EducationalApplication",
	  "operatingSystem": "Web",
	  "description": "Wordle Lab is an ultimate Wordle solver and entropy-based analyzer with Basic and Advanced modes.",
	  "inLanguage": ["en"],
	  "keywords": [
	    "Wordle lab", "Wordle helper", "Wordle analyzer", "Wordle solver", "Wordle entropy", "E[steps]", "expected candidates", "Max Bucket", "Next Guess Recommender", "Hard Mode", "Basic Mode", "Advanced Mode"
	  ],
	  "author": { "@type": "Person", "name": "Jaehong Kim" }
	}
	</script>
	
<style>

/* =====================================
   Wordle Lab ‚Äì Compact / Optimized CSS
   (Dark mode as base, Light overrides)
   ===================================== */

/* ========== Fonts ========== */
@font-face {
  font-family: "Lobster";
  src: url('./Lobster-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
}

/* ========== Design Tokens (Dark base) ========== */
:root{
  /* Core theme */
  --bg-main:#050608;
  --bg-card:rgba(20,22,30,0.96);
  --bg-card-soft:rgba(16,18,26,0.9);
  --bg-input:#151824;
  --border:#2a3040;
  --fg:#f6f7ff;
  --sub:#9aa1c5;
  --accent:#4dd0ff;
  --accent-soft:rgba(77,208,255,0.12);
  --danger:#ff6b81;
  --btn:#202538;
  --btnHover:#2b3250;
  --shadow:0 18px 40px rgba(0,0,0,0.55);
  --shadow-soft: 0 4px 14px rgba(0,0,0,0.15);
  --shadow-strong: 0 10px 28px rgba(0,0,0,0.22);
  --overlay:radial-gradient(circle at top,#151a33 0,rgba(5,6,8,0.7) 55%,rgba(3,4,6,0.88) 100%);
  --bg-bright:0.7;
  --bg-blur:0.4px;
  --font-main:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;

  /* Toast palette (dark base) */
  --toast-fg: #f7f7f8;
  --toast-bg: #1f2330;
  --toast-border: rgba(255,255,255,.08);
  --toast-success: #2fbf71;
  --toast-error:   #ff4d5e;
  --toast-info:    #8ea0ff;
  --toast-warn:    #ffc857;

  /* Panel tint tokens (dark base, soft) */
  --tint-green-soft:  rgba(46, 204, 113, 0.08);
  --tint-yellow-soft: rgba(241, 196, 15,  0.08);
  --tint-gray-soft:   rgba(149, 165, 166, 0.10);
  --tint-inc-soft:    rgba(64, 156, 255,  0.08);
  --tint-exc-soft:    rgba(229, 65, 95,   0.08);

  --tint-green-border:  rgba(46, 204, 113, 0.35);
  --tint-yellow-border: rgba(241,196, 15,  0.35);
  --tint-gray-border:   rgba(149,165,166, 0.35);
  --tint-inc-border:    rgba(64, 156, 255,  0.35);
  --tint-exc-border:    rgba(229,65, 95,    0.35);
}

/* Light theme overrides */
body.light{
  --bg-main:#f5f6fb;
  --bg-card:rgba(255,255,255,0.96);
  --bg-card-soft:rgba(255,255,255,0.94);
  --bg-input:#f3f4fd;
  --border:#d5d8ea;
  --fg:#141624;
  --sub:#667099;
  --accent:#5c6ffb;
  --accent-soft:rgba(92,111,251,0.09);
  --danger:#e5415f;
  --btn:#e3e6fb;
  --btnHover:#d6daf8;
  --shadow:0 16px 32px rgba(15,17,25,0.16);
  --overlay:radial-gradient(circle at top,#ffffff 0,#f5f6fb 50%,#eef0fa 100%);
  --bg-bright:1.2;
  --bg-blur:0.7px;

  /* Toast (light) */
  --toast-fg: #1b1d22;
  --toast-bg: #ffffff;
  --toast-border: rgba(0,0,0,.10);
  --toast-success: #1d8f5b;
  --toast-error:   #c9303d;
  --toast-info:    #4a64e0;
  --toast-warn:    #d9a100;

  /* Panel tints slightly stronger in light */
  --tint-green-soft:  rgba(46, 204, 113, 0.12);
  --tint-yellow-soft: rgba(241,196, 15,  0.12);
  --tint-gray-soft:   rgba(149,165,166, 0.14);
  --tint-inc-soft:    rgba(64, 156, 255,  0.12);
  --tint-exc-soft:    rgba(229, 65, 95,   0.12);

  --tint-green-border:  rgba(46, 204, 113, 0.45);
  --tint-yellow-border: rgba(241,196, 15,  0.45);
  --tint-gray-border:   rgba(149,165,166, 0.45);
  --tint-inc-border:    rgba(64, 156, 255,  0.45);
  --tint-exc-border:    rgba(229,65, 95,    0.45);
}

/* Dark mode: stronger tints + glass effect for panels */
body:not(.light) {
  --tint-green-soft:  rgba(46, 204, 113, 0.25);
  --tint-yellow-soft: rgba(241, 196, 15,  0.23);
  --tint-gray-soft:   rgba(189, 195, 199, 0.25);
  --tint-inc-soft:    rgba(64, 156, 255,  0.23);
  --tint-exc-soft:    rgba(231, 76, 60,   0.23);

  --tint-green-border:  rgba(46, 204, 113, 0.55);
  --tint-yellow-border: rgba(241, 196, 15,  0.55);
  --tint-gray-border:   rgba(189, 195, 199, 0.55);
  --tint-inc-border:    rgba(64, 156, 255,  0.60);
  --tint-exc-border:    rgba(231, 76, 60,   0.60);
}

/* ========== Reset & Base ========== */
*,*::before,*::after{box-sizing:border-box}
html,body{
  margin:0;
  padding:0;
}
body{
  min-height:100vh;
  font-family:var(--font-main);
  background:var(--bg-main);
  color:var(--fg);
}

/* ========== Background Images & Overlay ========== */
/* Dark mode image */
body::before{
  content:"";
  position:fixed;
  inset:0;
  background:url('./double-bubble-dark.png') center/460px repeat;
  filter:brightness(var(--bg-bright)) saturate(1) blur(var(--bg-blur));
  z-index:-2;
  pointer-events:none;
  will-change:transform;
}
/* Light mode image */
body.light::before{
  content:"";
  position:fixed;
  inset:0;
  background:url('./symphony.png') center/420px repeat;
  filter:brightness(1.3) saturate(1.05) blur(0.7px);
  z-index:-2;
  pointer-events:none;
  will-change:transform;
}
/* Overlay */
body::after{
  content:"";
  position:fixed;
  inset:0;
  background:var(--overlay);
  z-index:-1;
  pointer-events:none;
}

/* ========== Layout ========== */
.wrap{
  max-width:960px;
  margin:0 auto;
  padding:20px 16px 40px;
}

/* Header */
.header-row{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:12px;
  margin-bottom:14px;
}
h1{
  margin:0;
  font-size:26px;
  letter-spacing:0.03em;
}
h1 .tag{
  display:inline-block;
  margin-top:4px;
  font-size:13px;
  font-weight:400;
  color:var(--sub);
}
.brand{
  font-family:"Lobster", cursive;
}

/* ========== Cards, Rows, Lists ========== */
.card{
  background:var(--bg-card);
  border-radius:16px;
  border:1px solid var(--border);
  box-shadow:var(--shadow);
  padding:12px 14px;
  backdrop-filter:blur(18px);
  /* transition: background-color 0.5s ease-in-out, transform 0.5s ease-in-out; Transition for background and transform */
}
.row{
  display:flex;
  gap:12px;
  flex-wrap:wrap;
}
.list{
  max-height:220px;
  overflow:auto;
}

/* ================================
   Page-turn style panel animation
   ================================ */

@keyframes tabPanelSwipeRight {
  0% {
    transform: translateX(20px) rotateY(-7deg);
    opacity: 0.0;
    box-shadow: 0 0 0 rgba(0,0,0,0);
  }
  55% {
    transform: translateX(0) rotateY(0deg);
    opacity: 1;
    box-shadow: var(--shadow-strong);
  }
  100% {
    transform: translateX(0) rotateY(0deg);
    opacity: 1;
    box-shadow: var(--shadow-soft);
  }
}

@keyframes tabPanelSwipeLeft {
  0% {
    transform: translateX(-20px) rotateY(7deg);
    opacity: 0.0;
    box-shadow: 0 0 0 rgba(0,0,0,0);
  }
  55% {
    transform: translateX(0) rotateY(0deg);
    opacity: 1;
    box-shadow: var(--shadow-strong);
  }
  100% {
    transform: translateX(0) rotateY(0deg);
    opacity: 1;
    box-shadow: var(--shadow-soft);
  }
}

.tab-swipe-right {
  animation: tabPanelSwipeRight 0.23s cubic-bezier(.25, .9, .3, 1.1);
  transform-origin: 100% 50%; /* like turning from the right edge */
}

.tab-swipe-left {
  animation: tabPanelSwipeLeft 0.23s cubic-bezier(.25, .9, .3, 1.1);
  transform-origin: 0% 50%;   /* like turning from the left edge */
}

/* Stronger but elegant animation when switching Pos tabs 
@keyframes tabPanelFlash {
  0% {
    transform: scale(0.96) translateY(4px);
    opacity: 0.65;
    box-shadow: 0 0 0 rgba(0, 0, 0, 0);
  }
  60% {
    transform: scale(1.02) translateY(-1px);
    opacity: 1;
    box-shadow: var(--shadow-strong);
  }
  100% {
    transform: scale(1.0) translateY(0);
    opacity: 1;
    box-shadow: var(--shadow-soft); 
  }
} */

/* Apply the animation 
.tab-flash {
  animation: tabPanelFlash 0.22s cubic-bezier(.23,1.15,.32,1);
} */

/* ========== Buttons ========== */
.btn{
  background:var(--btn);
  border:1px solid var(--border);
  color:var(--fg);
  border-radius:999px;
  padding:7px 14px;
  font-size:13px;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  gap:6px;
  transition:
    background .15s ease,
    border-color .15s ease,
    transform .05s ease,
    box-shadow .15s ease;
}
.btn:hover{
  background:var(--btnHover);
  box-shadow:0 0 0 1px rgba(255,255,255,0.06);
  transform: translateY(1px);
}
.btn:active{
  transform:scale(.97);
  transform: translateY(3px);
}
.btn[disabled]{
  opacity:.55;
  cursor:not-allowed;
}

/* Theme / mode toggle buttons */
#modeToggle,
#modeSwitch{
  white-space:nowrap;
}

#filterModeToggle {
  width: 130px;
  min-width: 130px;
  /* display: flex;               flex container */
  align-items: center;         /* vertical center */
  justify-content: center;     /* horizontal center */
  text-align: center;
}

/* ========== Top Controls (word list / clear / mode toggle) ========== */
.bar{
  display:flex;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}
.top-controls{
  justify-content:space-between;
}
.top-controls-left{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center;
}
.top-controls-right{
  margin-left:auto;
}

/* Selects */
.bar select{
  padding:6px 10px;
  border-radius:999px;
  border:1px solid var(--border);
  background:var(--bg-input);
  color:var(--fg);
  font-size:13px;
}

/* Search input (Advanced mode / Pattern Search) */
.search{
  flex:1 1 200px;
}
.search input{
  width:100%;
  padding:8px 10px;
  border-radius:999px;
  border:1px solid var(--border);
  background:var(--bg-input);
  color:var(--fg);
  font-size:13px;
}
.search input::placeholder{
  color:var(--sub);
  opacity:.8;
}

/* Analyze input */
#analyzeInput{
  min-width:120px;
  padding:8px 10px;
  border-radius:10px;
  border:1px solid var(--border);
  background:var(--bg-input);
  color:var(--fg);
  font-size:13px;
}

/* ========== Letter Keyboards ========== */
/* Generic grid (Global / Position / Green / Yellow / Gray etc.) */
.grid{
  display:grid;
  grid-template-columns:repeat(13,minmax(0,1fr));
  gap:4px;
}

/* Gray Letter-only grid (bottom of Basic mode) */
.graygrid{
  display:grid;
  grid-template-columns:repeat(13,minmax(0,1fr));
  gap:4px;
}

/* Desktop: make Gray row 1√ó26 so buttons don‚Äôt look huge */
@media (min-width: 622px){
  .graygrid{
    grid-template-columns:repeat(26,1fr);
  }
}

/* Default key style */
.k{
  border-radius:10px;
  border:1px solid var(--border);
  padding:6px 0;
  text-align:center;
  font-size:13px;
  cursor:pointer;
  user-select:none;
  background:var(--bg-card-soft);
  color:var(--sub);
  transition:
    background .12s ease,
    border-color .12s ease,
    color .12s ease,
    transform .05s ease;
}
.k:hover{transform:translateY(-1px)}

/* Include / Exclude (Advanced mode) */
.k.inc{
  background:var(--accent-soft);
  border-color:var(--accent);
  color:var(--accent);
}
.k.exc{
  background:rgba(229,65,95,0.07);
  border-color:var(--danger);
  color:var(--danger);
}

/* Lock status during calculation */
.grid.locked .k,
.graygrid.locked .k{
  pointer-events:none;
  opacity:0.45;
}

/* ========== Easy Mode key colors (Green / Yellow / Gray) ========== */
/* Green: correct letter at this position */
#greenKeys .k.inc{
  background:rgba(46,204,113,0.18);
  border-color:#2ecc71;
  color:#2ecc71;
}
/* Yellow: present but not at this position */
#yellowKeys .k.exc{
  background:rgba(241,196,15,0.18);
  border-color:#f1c40f;
  color:#f1c40f;
}
/* Gray: not in the word at all (Global Exclude) */
#grayKeys .k.exc{
  background:rgba(149,165,166,0.2);
  border-color:#95a5a6;
  color:#95a5a6;
}

/* Extra Gray for dedicated gray grid (kept for clarity) */
.graygrid .k.exc{
  background:rgba(149,165,166,0.2);
  border-color:#95a5a6;
  color:#95a5a6;
}
.graygrid.locked .k{
  pointer-events:none;
  opacity:0.45;
}

/* ========== Tabs (Pos 1‚Äì5) ========== */
.tabs{
  display:grid;
  grid-template-columns:repeat(5,1fr);
  gap:8px;
}
.tab{
  border-radius:999px;
  border:1px solid var(--border);
  background:var(--bg-card-soft);
  color:var(--sub);
  padding:5px 10px;
  font-size:11px;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:4px;
}
.tab .num{font-weight:600}
.tab.active{
  background:var(--accent-soft);
  border-color:var(--accent);
  color:var(--accent);
}
@media(max-width:340px){
  .tab .label{display:none}
}

/* ========== Counter & Word list ========== */
.counter{
  margin-top:10px;
  font-size:13px;
  color:var(--sub);
}
.counter span{
  font-weight:600;
  font-size:18px;
  margin-right:3px;
}

/* Candidate word list */
#words{
  list-style:none;
  margin:0;
  padding:0;
  columns:4 110px;
  column-gap:12px;
  font-family:"SF Mono","Roboto Mono",ui-monospace,Menlo,Monaco,monospace;
  font-size:13px;
}
#words li{
  break-inside:avoid;
  padding:1px 0;
}

/* ========== Recommender controls ========== */
.ctl{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
}
.ctl label{
  font-size:13px;
  color:var(--sub);
  display:flex;
  gap:6px;
  align-items:center;
}
.ctl input[type="checkbox"]{
  accent-color:var(--accent);
}
.ctl select{
  padding:6px 8px;
  border-radius:999px;
  border:1px solid var(--border);
  background:var(--bg-input);
  color:var(--fg);
  font-size:13px;
}

/* Cands Thr / Pool Thr + Suggest / Stop / Reset */
.button-container{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center;
  margin-top:8px;
}
.button-container label{
  font-size:13px;
  color:var(--sub);
  display:flex;
  align-items:center;
  gap:6px;
}
.button-container input[type="number"]{
  width:86px;
  padding:6px;
  border-radius:10px;
  border:1px solid var(--border);
  background:var(--bg-input);
  color:var(--fg);
  font-size:13px;
}
.button-container .btn{
  padding-inline:14px;
  flex:0 0 auto;
}
#space-1{
  display:none;
  flex-basis:0;
}

/* ========== Progress bar ========== */
.progress{
  position:relative;
  height:6px;
  border-radius:999px;
  background:rgba(255,255,255,0.06);
  overflow:hidden;
}
.progress .barin{
  position:absolute;
  inset:0;
  width:0%;
  border-radius:inherit;
  background:linear-gradient(90deg,var(--accent),#7cf3ff);
  transition:width .12s linear;
}

/* ========== Tables ========== */
table{
  width:100%;
  border-collapse:collapse;
  font-size:13px;
}
th,td{
  padding:6px 8px;
  text-align:left;
  border-bottom:1px solid rgba(255,255,255,0.06);
}
th{
  font-size:12px;
  text-transform:uppercase;
  letter-spacing:0.05em;
  color:var(--sub);
  background:rgba(0,0,0,0.1);
}
body.light th{
  background:rgba(0,0,0,0.02);
}
td{color:var(--fg)}
td.mono{
  font-family:"SF Mono","Roboto Mono",ui-monospace,Menlo,Monaco,monospace;
}

/* Sortable headers */
th#sort-steps,
th#sort-entropy,
th#sort-cands,
th#sort-bucket{
  cursor:pointer;
}
th#sort-steps:focus,
th#sort-entropy:focus,
th#sort-cands:focus,
th#sort-bucket:focus{
  outline:2px solid var(--accent);
  outline-offset:2px;
}

/* ========== Help / Toggle sections ========== */
.help{
  margin-top:16px;
  font-size:13px;
  color:var(--sub);
}
.help ul{
  margin:6px 0 0;
  padding-left:18px;
}
.help li{margin-bottom:4px;}

.toggle-header{
  display:inline-block;
  margin-top:6px;
  cursor:pointer;
  user-select:none;
}
.toggle-header::before{
  content:"‚ñ∂";
  display:inline-block;
  margin-right:6px;
  font-size:10px;
  transform:translateY(-1px);
}
.toggle-header.open::before{
  content:"‚ñº";
}
.toggle-content{
  display:none;
  margin-top:4px;
}

/* Hints */
.hint{
  font-size:12px;
  color:var(--sub);
}

/* ========== Toasts ========== */
/* Container */
#toastContainer{
  position:fixed;
  left:50%;
  bottom:16px;
  transform:translateX(-50%);
  display:flex;
  flex-direction:column-reverse; /* newest on top visually */
  gap:8px;
  z-index:99999;
  pointer-events:none;
}

/* Each toast */
.toast{
  pointer-events:auto;
  min-width:220px;
  max-width:min(92vw,520px);
  padding:10px 12px;
  border-radius:10px;
  box-shadow:0 6px 18px rgba(0,0,0,.18);
  opacity:0;
  transform:translateY(8px);
  transition:opacity .22s ease, transform .22s ease;
  font-size:14px;
  line-height:1.25;

  background:var(--toast-bg);
  color:var(--toast-fg);
  border:1px solid var(--toast-border);
}
.toast.show{
  opacity:1;
  transform:translateY(0);
}
.toast.hide{
  opacity:0;
  transform:translateY(8px);
}

/* Legacy per-type palettes (borders) ‚Äì kept for compatibility */
body.light .toast.info  { border-color:#cdd9ff; }
body.light .toast.warn  { border-color:#ffe0a6; }
body.light .toast.ok    { border-color:#bfe8c9; }
body:not(.light) .toast.info { border-color:#2f3b5c; }
body:not(.light) .toast.warn { border-color:#5a3d12; }
body:not(.light) .toast.ok   { border-color:#1f4e31; }

/* Type accents via variables */
.toast.success{ color:var(--toast-success); }
.toast.error  { color:var(--toast-error); }
.toast.info   { color:var(--toast-info); }
.toast.warn   { color:var(--toast-warn); }

/* ========== Tinted Panels (Basic & Advanced) ========== */
/* BASIC: Green / Yellow / Gray panels */
#greenKeys{
  background:
    linear-gradient(135deg,var(--tint-green-soft),transparent 70%),
    var(--bg-card);
  border:1px solid var(--tint-green-border);
  border-radius:12px;
  padding:10px;
}
#yellowKeys{
  background:
    linear-gradient(135deg,var(--tint-yellow-soft),transparent 70%),
    var(--bg-card);
  border:1px solid var(--tint-yellow-border);
  border-radius:12px;
  padding:10px;
}
#grayKeys, .graygrid{
  background:
    linear-gradient(135deg,var(--tint-gray-soft),transparent 70%),
    var(--bg-card);
  border:1px solid var(--tint-gray-border);
  border-radius:12px;
  padding:10px;
}

/* ADVANCED: Global / Position Include / Exclude */
#gInc, #pInc{
  background:
    linear-gradient(135deg,var(--tint-inc-soft),transparent 70%),
    var(--bg-card);
  border:1px solid var(--tint-inc-border);
  border-radius:12px;
  padding:10px;
}
#gExc, #pExc{
  background:
    linear-gradient(135deg,var(--tint-exc-soft),transparent 70%),
    var(--bg-card);
  border:1px solid var(--tint-exc-border);
  border-radius:12px;
  padding:10px;
}

/* Dark mode: add extra glass / brightness */
body:not(.light) #greenKeys,
body:not(.light) #yellowKeys,
body:not(.light) #grayKeys,
body:not(.light) .graygrid,
body:not(.light) #gInc,
body:not(.light) #pInc,
body:not(.light) #gExc,
body:not(.light) #pExc{
  backdrop-filter:blur(20px) brightness(1.1);
}

/* Dark mode gradients slightly angled */
body:not(.light) #greenKeys{
  background:
    linear-gradient(120deg,var(--tint-green-soft) 0%,transparent 85%),
    var(--bg-card);
}
body:not(.light) #yellowKeys{
  background:
    linear-gradient(120deg,var(--tint-yellow-soft) 0%,transparent 85%),
    var(--bg-card);
}
body:not(.light) #grayKeys,
body:not(.light) .graygrid{
  background:
    linear-gradient(120deg,var(--tint-gray-soft) 0%,transparent 85%),
    var(--bg-card);
}
body:not(.light) #gInc,
body:not(.light) #pInc{
  background:
    linear-gradient(120deg,var(--tint-inc-soft) 0%,transparent 85%),
    var(--bg-card);
}
body:not(.light) #gExc,
body:not(.light) #pExc{
  background:
    linear-gradient(120deg,var(--tint-exc-soft) 0%,transparent 85%),
    var(--bg-card);
}

/* Keep buttons readable on tinted panels */
#greenKeys .k,
#yellowKeys .k,
#grayKeys .k,
.graygrid .k,
#gInc .k, #pInc .k,
#gExc .k, #pExc .k{
  background:var(--bg-card-soft);
}
#greenKeys .k:hover,
#yellowKeys .k:hover,
#grayKeys .k:hover,
.graygrid .k:hover,
#gInc .k:hover, #pInc .k:hover,
#gExc .k:hover, #pExc .k:hover{
  filter:brightness(1.05);
}

/* When locked, keep panel tone; only keys fade */
#gInc.locked, #pInc.locked,
#gExc.locked, #pExc.locked,
#greenKeys.locked, #yellowKeys.locked,
#grayKeys.locked, .graygrid.locked{
  opacity:1;
}

/* ========== Responsive Tweaks ========== */
@media(max-width:900px){
  #words{columns:3 110px}
}
@media(max-width:720px){
  body::before{
    filter:brightness(calc(var(--bg-bright) + 0.1)) saturate(1) blur(0.6px);
  }
  body.light::before{
    filter:brightness(1.35) saturate(1.1) blur(0.55px);
  }
  .wrap{padding-inline:10px}
  .header-row{
    flex-direction:column;
    align-items:flex-start;
  }
  #words{columns:2 110px}
}

/* Mobile: Cands/Pool one row, buttons one row */
@media(max-width:600px){
  .button-container label{
    flex:1 1 calc(50% - 6px);
  }
  #space-1{
    display:block;
    flex-basis:100%;
    height:0;
  }
  .button-container .btn{
    flex:1 1 calc(33.3% - 6px);
    justify-content:center;
  }

  .top-controls{
    flex-direction:column;
    align-items:stretch;
  }
  .top-controls-left{
    width:100%;
    justify-content:flex-start;
  }
  .top-controls-right{
    width:100%;
    display:flex;
    justify-content:flex-end;
  }
}


</style>

</head>

<body>
<div class="wrap">

<!-- Header -->
<div class="header-row">
	<h1>
		<span class="brand">
		Wordle Lab
		</span>
		<br>
		<span class="tag">
			Ultimate Wordle Solver &amp; Analyzer
		</span>
	</h1>
	<button class="btn" id="modeToggle" title="Toggle Dark/Light">
		‚òÄÔ∏è Light
	</button>
</div>

<!-- Top controls -->
<div class="card" style="margin-bottom:12px">
	<div class="bar top-controls">
		<div class="top-controls-left">
			<label for="wordListSelect" style="font-size:13px; color:var(--sub); margin-right:6px;">
				Select Word List
			</label>
			<select id="wordListSelect">
				<option value="wl2309">2,309 Word List (Default)</option>
				<option value="wl3200">3,200 Extended Word List</option>
				<option value="wl14855">14,855 Guessable Word List</option>
				<option value="custom">Custom Word List (Upload CSV)</option>
			</select>
			<input id="fileInput" type="file" accept=".txt,.csv" style="display:none">
		</div>
		<div class="top-controls-right">
			<button class="btn" id="clearAll" style="margin-right:5px">Clear Filters</button>
			<button id="filterModeToggle" class="btn">Advanced Mode</button>
		</div>
	</div>
</div>

<!--
<div class="card" style="margin-bottom:12px">
	<div class="bar">
		<label for="wordListSelect" style="font-size:13px; color:var(--sub); margin-right:6px;">
			Select Word List
		</label>
		<select id="wordListSelect">
			<option value="wl2309">2309 Word List (Default)</option>
			<option value="wl3200">3200 Extended Word List</option>

			<option value="custom">Custom Word List (Upload CSV‚Ä¶)</option>
		</select>
		<input id="fileInput" type="file" accept=".txt,.csv" style="display:none">
		<button class="btn" id="clearAll">
			Clear Filters
		</button>
		<button id="filterModeToggle" class="btn" title="Toggle Basic/Advanced" >
			Basic Mode
		</button>
	</div>
</div>
-->

<!-- Basic Mode -->
<div id="easyPanel" >
	<div class="card" style="margin-top:12px">
		<div class="tabs" id="easyTabs">
		</div>
		<div class="row" style="margin-top:10px">
			<div class="card" id="easyPosCardGreen" style="flex:1;min-width:280px">
				<div style="margin-bottom:8px">
					<strong>Green Letter</strong>
				</div>
				<div class="grid" id="greenKeys">
				</div>
			</div>
			<div class="card" id="easyPosCardYellow" style="flex:1;min-width:280px">
				<div style="margin-bottom:8px">
					<strong>Yellow Letter</strong>
				</div>
				<div class="grid" id="yellowKeys">
				</div>
			</div>
		</div>
	</div>
	<div class="card" style="margin-top:12px">
		<div style="margin-bottom:8px">
			<strong>Gray Letter</strong>
		</div>
		<div class="graygrid" id="grayKeys" ></div>
	</div>
</div>

<!-- Advanced Mode -->
<div id="proPanel" style="display:none">
	<div class="row" style="margin-top:12px">
		<div class="card" style="flex:1;min-width:320px">
			<div style="margin-bottom:8px">
				<strong>Global Include</strong>
			</div>
			<div class="grid" id="gInc">
			</div>
		</div>
		<div class="card" style="flex:1;min-width:320px">
			<div style="margin-bottom:8px">
				<strong>Global Exclude</strong>
			</div>
			<div class="grid" id="gExc">
			</div>
		</div>
	</div>
	<!-- Position include/exclude -->
	<div class="card" style="margin-top:12px">
		<div class="tabs" id="proTabs">
		</div>
		<div class="row" style="margin-top:10px">
			<div class="card" id="proPosCardInc" style="flex:1;min-width:280px">
				<div style="margin-bottom:8px">
					<strong>Position Include</strong>
				</div>
				<div class="grid" id="pInc">
				</div>
			</div>
			<div class="card" id="proPosCardExc" style="flex:1;min-width:280px">
				<div style="margin-bottom:8px">
					<strong>Position Exclude</strong>
				</div>
				<div class="grid" id="pExc">
				</div>
			</div>
		</div>
	</div>
	<!-- Search -->
	<div class="card" style="margin-top:12px">
		<div class="bar">
			<div style="margin-bottom:8px">
				<strong title="Use ?, *, [AEIOU], &amp; for pattern matching">Pattern Search</strong>
			</div>
			<div class="search">
				<input id="searchBox" placeholder="Search (see help below)" style="text-transform:uppercase;">
			</div>
		</div>
	</div>
</div>

<!-- Counter -->
<div class="counter">
	<span id="count">
		0
	</span>
	<small>candidates</small>
</div>

<!-- List -->
<div class="card list" style="margin-top:6px">
	<ul id="words">
	</ul>
</div>

<!-- Recommender -->
<div class="card" style="margin-top:12px">
	<div class="bar" style="justify-content:space-between">
		<div>
			<strong>Next-Guess Recommender</strong>
			<span class="tag">
				<!-- (Entropy-based) -->
			</span>
		</div>
	</div>
	<!-- Controls: row 1 -->
	<div class="ctl" style="margin-top:10px">
		<label title="Enforce feedback consistency (Wordle Hard Mode rules)">
			Hard Mode
			<input id="hardMode" type="checkbox">
			</input>
		</label>
		<label title="Guess pool used when Hard Mode is OFF">
			Guess Pool
			<select id="poolSelect">
				<option selected="" value="current">
					Current Word List
				</option>
				<option value="2309">
					2,309 Word List
				</option>
				<option value="3200">
					3,200 Word List
				</option>
				<option value="14855">
					14,855 Word List
				</option>
			</select>
		</label>
	</div>
	<!-- Controls: row 2 -->
	<div class="button-container">
		<label id="candsLabel" title="Cap the number of candidate guesses from the main candidate list">
			Cands Thr
			<input id="candsThreshold" min="1" type="number" value="200">
		</label>
		<label id="thrLabel" title="Cap the number of external guesses from the extended pool (applies only when Hard Mode is OFF)">
			Pool Thr
			<input id="poolThreshold" min="0" type="number" value="200">
		</label>
		<button id="suggestNext" class="btn">
			Suggest
		</button>
		<button id="stopBtn" class="btn">
			Stop
		</button>
		<button id="resetSuggest" class="btn">
			Reset
		</button>
	</div>
	<div class="hint" id="modeNote" style="margin-top:4px">
		Hint
	</div>
	<!-- Progress + status -->
	<div class="progress" style="margin-top:10px">
		<div class="barin" id="pbar">
		</div>
	</div>
	<div class="hint" id="suggestStatus" style="margin-top:8px">
	</div>
	<!-- Table -->
	<div style="overflow:auto;margin-top:8px">
		<table>
			<thead>
				<tr>
					<th>
						Word
					</th>
					<th id="sort-steps" role="button" tabindex="0" title="Click to show the Top 10 by E[steps] (smaller is better)">
						E[steps]
					</th>
					<th id="sort-entropy" role="button" tabindex="0" title="Click to show the Top 10 by Entropy (higher is better)">
						Entropy
					</th>
					<th id="sort-cands" role="button" tabindex="0" title="Click to show the Top 10 by E[cands] (smaller is better)">
						E[cands]
					</th>
					<th id="sort-bucket" role="button" tabindex="0" title="Click to show the Top 10 by Max Bucket (smaller is better)">
						Max Bucket
					</th>
				</tr>
			</thead>
			<tbody id="suggestTable">
			</tbody>
		</table>
	</div>
</div>


<!-- Analyze Word -->
<div class="card" id="analyzeCard" style="margin-top:12px">
	<div class="bar" style="justify-content:space-between; gap:8px;">
		<div>
			<strong>Analyze Word</strong>
			<span class="tag">
				<!-- (w.r.t. current candidate list) -->
			</span>
		</div>
		<div class="bar" style="gap:6px;">
			<input id="analyzeInput" maxlength="5" placeholder="5-letter word" style="text-transform:uppercase;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:var(--input);color:var(--fg)">
			<button class="btn" id="analyzeBtn">
				Analyze
			</button>
		</div>
	</div>
		<div style="overflow:auto;margin-top:10px">
			<table>
				<thead>
					<tr>
						<th>
							Word
						</th>
						<th>
							E[steps]
						</th>
						<th>
							Entropy
						</th>
						<th>
							E[cands]
						</th>
						<th>
							Max Bucket
						</th>
					</tr>
				</thead>
				<tbody id="analyzeTable">
				</tbody>
			</table>
		</div>
</div>


<!-- Help -->
<div class="help">
	<!-- Word Lists for Wordle -->
	<strong id="wordListsToggle" class="toggle-header">Word Lists for Wordle</strong>
	<div id="wordListsContent" class="toggle-content">
		<p>Here are three commonly referenced word lists associated with the game Wordle: the ‚Äú2,309‚Äù, ‚Äú3,200‚Äù, and ‚Äú14,855‚Äù word lists. None of these lists have been officially confirmed as the definitive answer sets by the creators of Wordle.</p>
		<ul>
			<li>
				<strong>2,309 Word List</strong>: <p>Many players report seeing answers from this 2,309‚Äëword list, though there are exceptions.</p>
			</li>
			<li>
				<strong>3,200 Word List</strong>: <p>The 3,200‚Äëword list is often used as a broader ‚Äúanswers‚Äù list in community tools.</p>
			</li>
			<li>
				<strong>14,855 Word List</strong>: <p>This much larger list, containing 14,855 words, is believed to reflect the broader vocabulary of words accepted by the game as guesses (rather than necessarily as answers).</p>
			</li>
		</ul>
		<p>Each of these lists plays a different role: the 2,309 list as a common answers reference, the 3,200 list for extended answer coverage, and the 14,855 list for comprehensive guess vocabulary.</p>
	</div>
	<br>
	<!-- Next-Guess Recommender Help -->
	<strong id="recommenderToggle" class="toggle-header">Next-Guess Recommender Help</strong>
	<div id="recommenderContent" class="toggle-content">
		<ul>
			<br>
			<li>
				<strong>Next-Guess Recommender</strong>: This tool uses an <strong>entropy-based</strong> approach to narrow down the list of candidate guesses. Initially, it ranks words based on their <strong>entropy</strong>, which measures the uncertainty or information content of the words. After narrowing down the candidates using entropy, other factors such as <strong>E[steps]</strong>, <strong>E[cands]</strong>, and <strong>max bucket</strong> are used to further refine the recommendations.
			</li>
			<br>
			<li>
				<strong>ENTROPY</strong>: A measure of uncertainty, where higher values indicate words with more potential for narrowing down the solution space. Entropy values represent how "informative" a word is when used as a guess.
			</li>
			<li>
				<strong>E[STEPS]</strong>: An estimate of the number of steps required to guess the target word, given the current pool of candidate words. This is an approximation and may not always be 100% accurate.
			</li>
			<li>
				<strong>E[CANDS]</strong>: The expected number of candidates remaining after a guess, based on the current word pool. This metric helps assess how effective a guess is in reducing the search space.
			</li>
			<li>
				<strong>MAX BUCKET</strong>: The size of the largest group of words that would result from guessing a particular word, given the current state of the game. This value helps identify words that will divide the remaining possibilities evenly.
			</li>
 			<br>
			<li>
				<strong>Hard Mode ON</strong>: Guesses are made only from the top-ranked (Cands Thr) candidates based on entropy.
			</li>
			<li>
				<strong>Hard Mode OFF</strong>: Guesses are made from both the top-ranked (Cands Thr) candidates and top-ranked words from the external pool (Pool Thr), based on entropy.
			</li>
			<li>
				<strong>Cands Thr (Candidates Threshold)</strong>: The maximum number of top-ranked candidate guesses from the main candidate list, selected based on entropy, used for the recommendation.
			</li>
			<li>
				<strong>Pool Thr (Pool Threshold)</strong>: The maximum number of top-ranked external pool guesses, selected based on entropy, used for the recommendation (only applies when Hard Mode is OFF).
			</li>
		</ul>
	</div>
	<br>
	<!-- Search Help -->
	<strong id="searchHelpToggle" class="toggle-header">Pattern Search Help</strong>
	<div id="searchHelpContent" class="toggle-content">
		<ul>
			<li>
				<strong>?</strong>: Exactly one letter (e.g.,<code>A?E</code>&rarr;<em>ACE, APE, ARE</em>)
			</li>
			<li>
				<strong>*</strong>: Zero or more letters (e.g.,<code>E*E</code>&rarr;<em>AGREE, EAGLE, EERIE</em>)
			</li>
			<li>
				<strong>[AEIOU]</strong>: Any one listed; <strong>[^AEIOU]</strong>: Not these (e.g.,<code>[^AEIOU]ATE</code>&rarr;<em>SLATE, CRATE</em>)
			</li>
			<li>
				<strong>&amp;</strong>: AND; <strong>|</strong>: OR (AND has higher precedence)
			</li>
			<li>
				<strong>( )</strong>: Group terms (e.g.,<code>(ING &amp; R) | (A?E &amp; N)</code>)
			</li>
		</ul>
	</div>
	<br>
</div>

</div>


<script>

/* ===== Utilities & State ===== */
const byId=id=>document.getElementById(id);
const ALPHA=Array.from({length:26},(_,i)=>String.fromCharCode(65+i));
const state={
	all:[], filtered:[], search:'',
	searchTester:null,
	globalInclude:new Set(), globalExclude:new Set(),
	pos:Array.from({length:5},()=>({include:new Set(),exclude:new Set()})),
	activePos:0,
	base2309:[], base3200:[], base14855:[],
	cancel:false
};


/* ===== Theme ===== */
(function(){
	const s=localStorage.getItem('wf-theme');
	if(s==='light')document.body.classList.add('light');
	updateThemeBtn(); byId('modeToggle').onclick=toggleTheme;
})();
function toggleTheme(){
	document.body.classList.toggle('light');
	localStorage.setItem('wf-theme',document.body.classList.contains('light')?'light':'dark');
	updateThemeBtn();
}
function updateThemeBtn(){
	byId('modeToggle').textContent=document.body.classList.contains('light')?'üåô Dark':'‚òÄÔ∏è Light';
}

/* ===== CSV parsing & loading ===== */
function parseWordsFromCsvText(t){
	const lines=t.split(/\r?\n/);const words=[];const seen=new Set();
	for(const raw of lines){
		const line=raw.trim();
		if(!line) continue;
		const cells=line.split(/,|\s+/);
		for(let c of cells){
			c=(c||'').trim().toLowerCase();
			if(/^[a-z]{5}$/.test(c)&&!seen.has(c)){
				seen.add(c);
				words.push(c);
			}
		}
	}
	return words;
}
async function fetchCsv(name){
	const res=await fetch(`./${name}`,{cache:'no-store'});
	if(!res.ok) throw new Error('fetch failed: '+name);
	return parseWordsFromCsvText(await res.text());
}
async function loadCsvFile(name){
	try{
		lockUI(true);
		const words=await fetchCsv(name);
		loadWordsFromArray(words);
	} catch(e) {
		alert('Error loading '+name+': '+e.message);
	}
	finally{
		lockUI(false);
	}
}

let currentMode = 'easy'; 

// === Easy / Pro filter mode toggle ===
function setFilterMode(mode) {
	const proPanel  = byId('proPanel');   // Pro-mode container
	const easyPanel = byId('easyPanel');  // Easy-mode container
	const btn       = byId('filterModeToggle');
	if (!proPanel || !easyPanel || !btn) return;
	// Show warning toast when switching to Basic Mode
	if (currentMode === 'pro' && mode === 'easy') {
		showToast("Some advanced filters may not be reflected in Basic Mode.", "warn");
		// showToast("Switching to Basic Mode may hide some advanced filters.", "warn");
	}
	if (mode === 'pro') {
		// Show Pro panel, hide Easy panel
		proPanel.style.display  = '';
		easyPanel.style.display = 'none';
		btn.textContent = 'Basic Mode';
		btn.title       = 'Click to switch to Basic Mode';
	} else {
		// Default: Easy mode
		proPanel.style.display  = 'none';
		easyPanel.style.display = '';
		btn.textContent = 'Advanced Mode';
		btn.title       = 'Click to switch to Advanced Mode';
	}
	currentMode = mode;
	// Optional: remember in localStorage
	// localStorage.setItem('wf-filter-mode', mode);
}

function initFilterModeToggle() {
	const btn = byId('filterModeToggle');
	if (!btn) return;
	// Initial mode: Easy (you can change to 'pro' if you want)
	setFilterMode('easy');
	btn.addEventListener('click', () => {
		const proPanel = byId('proPanel');
		const isProVisible =
		proPanel && proPanel.style.display !== 'none';
		// Toggle between 'easy' and 'pro'
		setFilterMode(isProVisible ? 'easy' : 'pro');
	});
}

/* ===== Notifications ===== */
function toast(msg, ms=1800){
	let el = document.getElementById('toast');
	if(!el){
		el = document.createElement('div');
		el.id = 'toast';
		document.body.appendChild(el);
	}
	el.textContent = msg;
	el.classList.add('show');
	clearTimeout(el._t);
	el._t = setTimeout(()=>el.classList.remove('show'), ms);
}


/* ===== Toast API (global) ===== */
(function(){
	const MAX_TOASTS = 5;
	const TOAST_DURATION = 2200;
	let _toastContainer = null;

	function getToastContainer(){
		if (_toastContainer) return _toastContainer;
		let el = document.getElementById('toastContainer');
		if (!el){
			el = document.createElement('div');
			el.id = 'toastContainer';
			document.body.appendChild(el);
		}
		_toastContainer = el;
		return el;
	}

	function removeOldestIfNeeded(container){
		while (container.children.length >= MAX_TOASTS){
			container.lastElementChild?.remove();
		}
	}

	function safeRemoveLater(el, delay){
		setTimeout(()=>{ if (el.isConnected) el.remove(); }, delay);
	}

	window.clearToasts = function(){
		const c = getToastContainer();
		c.innerHTML = '';
	};

	window.showToast = function(message, type='info'){
		try{
			const container = getToastContainer();
			removeOldestIfNeeded(container);

			const t = document.createElement('div');
			t.className = `toast ${type}`;
			const span = document.createElement('span');
			span.textContent = message;
			t.appendChild(span);

			// Paired with column-reverse: The latest toast is visually lower
			container.prepend(t);
			// Paired with column: The latest toast is visually higher
			container.appendChild(t);

			// show state one frame later
			requestAnimationFrame(()=> t.classList.add('show'));

			// Hide transition after a certain amount of time
			setTimeout(()=> t.classList.add('hide'), TOAST_DURATION - 150);

			// Remove DOM after transition ends
			t.addEventListener('transitionend', (e)=>{
				if (e.propertyName === 'opacity' && t.classList.contains('hide')){
					t.remove();
				}
			});

			// Forced removal in case of emergency
			safeRemoveLater(t, TOAST_DURATION + 800);
		}catch(err){
			console.error('showToast error:', err);
		}
	};


})();


/* ===== Keyboards & Tabs ===== */
function buildKeyboard(container, kind) {
	container.innerHTML = '';
	for (const ch of ALPHA) {
		const d = document.createElement('div');
		d.className = 'k';
		d.textContent = ch;
		d.dataset.ch = ch.toLowerCase();
		d.onclick = () => {
			const letter = d.dataset.ch;
			if (kind === 'gInc') {
				const hadGray     = state.globalExclude.has(letter); // global Gray before toggle?
				// Global Include: normal toggle between globalInclude / globalExclude 
				toggle(state.globalInclude, state.globalExclude, letter);
					if (hadGray) {
						showToast(`"${letter.toUpperCase()}" was removed from Global Exclude.`, "error");
					}
			} else if (kind === 'gExc') {
				// Global Exclude:
				// 1) Remember previous state (was it already excluded?)
				const wasExcluded = state.globalExclude.has(letter);
				const wasIncluded = state.globalInclude.has(letter);
				// 2) Normal toggle between globalExclude / globalInclude
				toggle(state.globalExclude, state.globalInclude, letter);
				// 3) If it just became "excluded" now, remove from ALL position includes
				const isNowExcluded = state.globalExclude.has(letter);
				if (!wasExcluded && isNowExcluded) {
					let cleared = false;
					for (const pos of state.pos) {
						if (pos.include.delete(letter)) cleared = true;
					}
					if (cleared || wasIncluded) {
						showToast(`"${letter.toUpperCase()}" was removed from all Global and Position Includes.`, "error");
					}
				}
			} else if (kind === 'pInc') {
				// pInc: this position must be this letter (only one allowed)
				const slot = state.pos[state.activePos];
				if (slot.include.size === 1 && slot.include.has(letter)) {
					// Same letter clicked again ‚Üí turn this pInc OFF
					slot.include.clear();
				} else {
					// Turn this position's pInc ON for this letter
					slot.include.clear();
					slot.include.add(letter);
					// Make sure this position is NOT pExc for the same letter
					if (slot.exclude.delete(letter)) {
						showToast(`"${letter.toUpperCase()}" was removed from Position Exclude (Position ${state.activePos + 1}).`, "error");
					}
					if (state.globalExclude.delete(letter)) {
						showToast(`"${letter.toUpperCase()}" was removed from Global Exclude.`, "error");
					}
				}	
				/* if (!wasIncluded && isNowIncluded) {
					const msgs = [];
					// Show toast if we actually cleared a same-position Yellow
					if (hadYellow) {
						// pos.exclude.delete(letter);
						msgs.push(`"${letter.toUpperCase()}" was cleared from Position ${state.activePos + 1} Exclude`);
					}
					// Resolve global Gray conflict and toast (only if it existed before)
					if (hadGray) {
						state.globalExclude.delete(letter);
						msgs.push(`"${letter.toUpperCase()}" was cleared from Global Exclude`);
					}
					// (We intentionally do NOT auto-add to globalInclude)
					if (msgs.length) toast(msgs.join(' ¬∑ '));
				} */
			} else if(kind === 'pExc') {
				// pExc (Position Exclude) ‚Äì normal per-position toggle
				const pos = state.pos[state.activePos];
				const wasIncluded = pos.include.has(letter);
				toggle(pos.exclude, pos.include, letter);
				if (wasIncluded) {
					showToast(`"${letter.toUpperCase()}" was removed from Position Include (Position ${state.activePos + 1}).`, "error");
				}
			} else if (kind === 'easyGreen') {
				// Green: this position must be this letter (only one allowed)
				const slot = state.pos[state.activePos];
				if (slot.include.size === 1 && slot.include.has(letter)) {
					// Same letter clicked again ‚Üí turn this green OFF
					slot.include.clear();
					//  Check if this letter is used anywhere else (as Green or Yellow)
					let stillUsed = false;
					for (let i = 0; i < 5; i++) {
						if (state.pos[i].include.has(letter) || state.pos[i].exclude.has(letter)) {
							stillUsed = true;
							break;
						}
					}
					if (!stillUsed) {
						// If nowhere else, also remove from globalInclude
						state.globalInclude.delete(letter);
					}
				} else {
					// Turn this position's green ON for this letter
					state.globalInclude.add(letter); // globalInclude ON when green active
					slot.include.clear();
					slot.include.add(letter);
					// Make sure this position is NOT yellow for the same letter
					if (slot.exclude.delete(letter)) {
						showToast(`"${letter.toUpperCase()}" was removed from Yellow Letter (Position ${state.activePos + 1}).`, "error");
					}
					if (state.globalExclude.delete(letter)) {
						showToast(`"${letter.toUpperCase()}" was removed from Gray Letter.`, "error");
					}
				}
			} else if (kind === 'easyYellow') {
				// Yellow: letter appears somewhere, but NOT at this position
				const slot = state.pos[state.activePos];
				const wasIncluded = slot.include.has(letter);
				const hadGray     = state.globalExclude.has(letter);
				if (slot.exclude.has(letter)) {
					// Toggle this yellow OFF on this position
					slot.exclude.delete(letter);
					// If this letter is no longer used on ANY position, relax globalInclude
					let stillUsed = false;
					for (let i = 0; i < 5; i++) {
						if (state.pos[i].include.has(letter) || state.pos[i].exclude.has(letter)) {
							stillUsed = true;
							break;
						}
					}
					if (!stillUsed) {
						state.globalInclude.delete(letter);
					}
				} else {
					// Turn yellow ON on this position
					slot.exclude.add(letter);
					// Make sure it is NOT green on this same position
					if (wasIncluded) {
						slot.include.delete(letter);
						showToast(`"${letter.toUpperCase()}" was removed from Green Letter (Position ${state.activePos + 1}).`, "error");
					}
					if (hadGray) {
						state.globalExclude.delete(letter);
						showToast(`"${letter.toUpperCase()}" was removed from Gray Letter.`, "error");
					}
					// Letter exists somewhere, so keep it out of globalExclude
					state.globalInclude.add(letter);
				}
			} else if (kind === 'easyGray') {
				// Gray: letter is nowhere in the word ‚Üí flip globalExclude/globalInclude
				const letter = d.dataset.ch;
				const wasExcluded = state.globalExclude.has(letter);
				// Toggle: add to globalExclude (and remove from globalInclude), or the reverse
				toggle(state.globalExclude, state.globalInclude, letter);
				const isNowExcluded = state.globalExclude.has(letter);
				// Only when we just turned the letter GRAY (excluded) do we clear per-position flags
				let cleared = false;
				if (isNowExcluded) {
					for (let i = 0; i < 5; i++) {
						const a = state.pos[i].include.delete(letter); // green at pos i
						const b = state.pos[i].exclude.delete(letter); // yellow at pos i
						if (a || b) cleared = true;
					}
				}
				// Show toast ONLY if gray just cleared something from Green/Yellow
				if (isNowExcluded && cleared) {
					showToast(`"${letter.toUpperCase()}" was removed from all Green and Yellow Letters.`, "error");
				}
			}
			// Re-render keyboards and apply new filters
			refresh();
			apply();
		};
		container.appendChild(d);
	}
}

function toggle(primary,secondary,ch){
	if(primary.has(ch)) primary.delete(ch);
	else {
		primary.add(ch);
		secondary.delete(ch);
	}
}
function refresh(){
	const gI=byId('gInc').children, gE=byId('gExc').children, pI=byId('pInc').children, pE=byId('pExc').children;
	for(const e of gI) e.classList.toggle('inc',state.globalInclude.has(e.dataset.ch));
	for(const e of gE) e.classList.toggle('exc',state.globalExclude.has(e.dataset.ch));
	for(const e of pI) e.classList.toggle('inc',state.pos[state.activePos].include.has(e.dataset.ch));
	for(const e of pE) e.classList.toggle('exc',state.pos[state.activePos].exclude.has(e.dataset.ch));
	// === Easy mode keyboards (if present) ===
	const gK = byId('greenKeys')?.children  || [];
	const yK = byId('yellowKeys')?.children || [];
	const gr = byId('grayKeys')?.children   || [];
	const slot = state.pos[state.activePos];
	// Green: behave like Position Include
	for(const e of gK){
		e.classList.toggle('inc', slot.include.has(e.dataset.ch));
		e.classList.remove('exc'); 
	}
	// Yellow: behave like Position Exclude
	for(const e of yK){
		e.classList.toggle('exc', slot.exclude.has(e.dataset.ch));
		e.classList.remove('inc');
	}
	// Gray: behave like Global Exclude
	for(const e of gr){
		e.classList.toggle('exc', state.globalExclude.has(e.dataset.ch));
		e.classList.remove('inc');
	}
	/* for(const t of byId('tabs').children) t.classList.toggle('active',Number(t.dataset.idx)===state.activePos); */
	// Tabs in both Pro & Easy panels
	for (const tabsId of ['proTabs', 'easyTabs']) {
		const tabs = byId(tabsId);
		if (!tabs) continue;
		for (const t of tabs.children) {
			t.classList.toggle('active', Number(t.dataset.idx) === state.activePos);
		}
	}
}

// Animate the position panel when user switches Pos 1‚Äì5
function animatePosPanelOnTabChange() {
  const proPanel = byId('proPanel');
  const easyPanel = byId('easyPanel');

  const isProVisible = proPanel && proPanel.style.display !== 'none';

  const panels = [];

  if (isProVisible) {
    // Advanced Mode: animate Position Include / Position Exclude cards
    const pIncGrid = byId('pInc');
    const pExcGrid = byId('pExc');

    const pIncCard = pIncGrid ? pIncGrid.closest('.card') : null;
    const pExcCard = pExcGrid ? pExcGrid.closest('.card') : null;

    if (pIncCard) panels.push(pIncCard);
    if (pExcCard) panels.push(pExcCard);

  } else {
    // Basic Mode: animate Green / Yellow cards
    const gGrid = byId('greenKeys');
    const yGrid = byId('yellowKeys');

    const gCard = gGrid ? gGrid.closest('.card') : null;
    const yCard = yGrid ? yGrid.closest('.card') : null;

    if (gCard) panels.push(gCard);
    if (yCard) panels.push(yCard);
  }

  // Apply the CSS animation class briefly
  panels.forEach(panel => {
    panel.classList.remove('tab-flash');  // reset if already applied
    void panel.offsetWidth;              // force reflow to restart animation
    panel.classList.add('tab-flash');

    // Clean up the class after animation ends
    setTimeout(() => {
      panel.classList.remove('tab-flash');
    }, 220); // slightly longer than CSS animation duration
  });
}

let lastActivePos = 0;  // remember previous tab index for swipe direction

function renderTabs() {
	const containers = [
	byId('proTabs'),
	byId('easyTabs')
	].filter(Boolean);  
	for (const tabs of containers) {
		tabs.innerHTML = '';
		for (let i = 0; i < 5; i++) {
			const b = document.createElement('button');
			b.className = 'tab' + (i === state.activePos ? ' active' : '');
			b.innerHTML = '<span class="label">Pos </span><span class="num">' + (i + 1) + '</span>';
			b.dataset.idx = i;
			b.onclick = () => {
				// determine swipe direction BEFORE updating activePos
				const newIdx = i;
				const oldIdx = state.activePos;
				const dir = (newIdx > oldIdx) ? 'right' :
				            (newIdx < oldIdx) ? 'left' : null;
				lastActivePos = oldIdx;
				state.activePos = newIdx;
				// if (state.activePos === i) return;  // clicking same tab: do nothing
				// state.activePos = i;
				refresh();
				if (dir) {
					flashPosPanels(dir);
				}
				// animatePosPanelOnTabChange();
			};
			tabs.appendChild(b);
		}
	}
}

function flashPosPanels(direction) {
  const easyCardGreen = byId('easyPosCardGreen');
  const easyCardYellow = byId('easyPosCardYellow');
  const proCardInc  = byId('proPosCardInc');
  const proCardExc  = byId('proPosCardExc');
  const clsLeft  = 'tab-swipe-left';
  const clsRight = 'tab-swipe-right';
  const cls = (direction === 'right') ? clsRight : clsLeft;

  [easyCardGreen, easyCardYellow, proCardInc, proCardExc].forEach(panel => {
    if (!panel) return;
    // remove any previous animation classes
    panel.classList.remove(clsLeft, clsRight);

    // force reflow so animation can restart
    void panel.offsetWidth;

    // add new class
    panel.classList.add(cls);

    // clean up class after animation ends
    setTimeout(() => {
      panel.classList.remove(clsLeft, clsRight);
    }, 260); // a bit bigger than animation duration
  });
}


/* ===== Search expression ===== */
function sanitizeClassContent(s){
	const x=s.toLowerCase().replace(/\s+/g,'');
	if(!/^[a-z\-\^]*$/.test(x)) return null;
	return x;
}
function escapeRe(s){
	return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
}
function buildRegexFromMiniPattern(q){
	let reStr='';
	for(let i=0;i<q.length;i++){
		const ch=q[i];
		if(ch==='*'){
			let j=i;
			while(j<q.length&&q[j]==='*') j++;
			reStr+='[a-z]*';
			i=j-1;
		} else if(ch==='?'){
			reStr+='[a-z]';
		} else if(ch==='['){
			let j=i+1;
			while(j<q.length&&q[j]!==']') j++;
			if(j<q.length){
				const s=q.slice(i+1,j);
				const ok=sanitizeClassContent(s);
				if(ok!==null){
					reStr+=`[${ok}]`;
					i=j;
				} else reStr+='\\[';
			} else reStr+='\\[';
		} else if(ch===' '){
			/* ignore */
		} else if(/[a-z]/.test(ch)){
			reStr+=ch;
		} else reStr+=escapeRe(ch);
	}
	return new RegExp(reStr);
}
function tokenize(expr){
	const s=(expr||'').toLowerCase();
	const out=[];
	let i=0;
	const isOp=c=>c==='|'||c==='&';
	while(i<s.length){
		const c=s[i];
		if(c===' '){
			i++;
			continue;
		}
		if(c==='('||c===')'||isOp(c)){
			out.push({type:c});
			i++;
			continue;
		}
		let buf='';
		while(i<s.length){
			const ch=s[i];
			if(ch==='('||ch===')'||isOp(ch)||ch===' ') break;
			if(ch==='['){
				let j=i+1;
				while(j<s.length&&s[j]!==']') j++;
				if(j<s.length){
					buf+=s.slice(i,j+1);
					i=j+1;
					continue;
				} else {
					buf+='[';
					i++;
					continue;
				}
			}
			buf+=ch; i++;
		} out.push({
			type:'pat',value:buf
		});
	} return out;
}
function toRPN(tokens){
	const out=[], st=[];
	const prec=t=>t.type==='&'?2:(t.type==='|'?1:0);
	const isOp=t=>t.type==='|'||t.type==='&';
	for(const t of tokens){
		if(t.type==='pat') out.push(t);
		else if(isOp(t)){
			while(st.length){
				const top=st[st.length-1];
				if(isOp(top)&&prec(top)>=prec(t)) out.push(st.pop());
				else break;
			}
			st.push(t);
		} else if(t.type==='(') st.push(t);
		else if(t.type===')'){
			while(st.length&&st[st.length-1].type!=='(') out.push(st.pop());
			if(st.length&&st[st.length-1].type==='(') st.pop();
		}
	}
	while(st.length){
		const x=st.pop();
		if(x.type!=='('&&x.type!==')') out.push(x); 
	} return out;
}
function buildTesterFromRPN(rpn){
	const st=[]; 
	for(const t of rpn){
		if(t.type==='pat'){
			const re=buildRegexFromMiniPattern(t.value);
			st.push(w=>re.test(w));
		} else if(t.type==='&'||t.type==='|'){
			const b=st.pop(), a=st.pop();
			if(!a||!b) return null;
			st.push(t.type==='&'?(w)=>a(w)&&b(w):(w)=>a(w)||b(w));
		}
	}
	return st.length===1?st[0]:null;
}
function buildSearchTester(expr){
	const toks=tokenize(expr);
	if(!toks.some(t=>t.type==='pat')) return null;
	const rpn=toRPN(toks);
	const tester=buildTesterFromRPN(rpn);
	return tester||null;
}

/* ===== Filter & list ===== */
function apply(){
	const out=[];
	const gi=state.globalInclude, ge=state.globalExclude;
	const tester=state.searchTester;
	WORDS: for(const w of state.all){
		if(tester && !tester(w)) continue;
		for(const ch of ge) if(w.includes(ch)) continue WORDS;
		for(const ch of gi) if(!w.includes(ch)) continue WORDS;
		for(let i=0;i<5;i++){
			const need=state.pos[i].include, ban=state.pos[i].exclude, c=w[i];
			if(need.size>0 && !need.has(c)) continue WORDS;
			if(ban.has(c)) continue WORDS;
		}
		out.push(w);
	}
	state.filtered=out;
	renderList();
}
function renderList(){
	const ul=byId('words');
	ul.innerHTML='';
	for(const w of state.filtered){
		const li=document.createElement('li');
		li.textContent=w.toUpperCase();
		ul.appendChild(li);
	}
	byId('count').textContent=state.filtered.length;
}
function loadWordsFromArray(a){
	const seen=new Set();
	state.all=a.filter(w=>/^[a-z]{5}$/.test(w)&&!seen.has(w)&&seen.add(w)).sort();
	apply();
}

/* ===== Wordle feedback ===== */
function pattern(guess, answer){
	const g=[...guess], a=[...answer];
	const res=Array(5).fill('0');
	const cnt={};
	for(let i=0;i<5;i++){
		if(a[i]===g[i]){
			res[i]='2';
		} else {
			cnt[a[i]]=(cnt[a[i]]||0)+1;
		}
	}
	for(let i=0;i<5;i++){
		if(res[i]==='2') continue;
		const ch=g[i];
		if(cnt[ch]>0){
			res[i]='1';
			cnt[ch]--;
		}
	}
	return res.join('');
}
function partitionByPattern(S, guess){
	const map=new Map();
	for(const ans of S){
		const p=pattern(guess, ans);
		let arr=map.get(p);
		if(!arr){
			arr=[];
			map.set(p,arr);
		}
		arr.push(ans);
	}
	return map;
}
function entropyAndExpectedSize(S, guess){
	const parts=partitionByPattern(S, guess);
	const n=S.length;
	let H=0, exp=0, maxb=0;
	for(const arr of parts.values()){
		const p=arr.length/n;
		H += -p*Math.log2(p);
		exp += p*arr.length;
		if(arr.length>maxb) maxb=arr.length;
	}
	return {
		entropy:H, expected:exp, maxBucket:maxb
	};
}

/* ===== External pools (lazy load) ===== */
async function ensurePoolLoaded(which){
	if(which==='2309' && !state.base2309.length){
		state.base2309 = await fetchCsv('wordle_solutions_2309.csv');
	}
	if(which==='3200' && !state.base3200.length){
		state.base3200 = await fetchCsv('wordle_solutions_3200.csv');
	}
	if(which==='14855'&& !state.base14855.length){
		state.base14855= await fetchCsv('wordle_solutions_14855.csv');
	}
}
async function getExternalPool(){
	const sel=byId('poolSelect').value;
	if(sel==='current') return state.all;        // current loaded list
	await ensurePoolLoaded(sel);
	if(sel==='2309')  return state.base2309.length? state.base2309 : state.all;
	if(sel==='3200')  return state.base3200.length? state.base3200 : state.all;
	if(sel==='14855') return state.base14855.length? state.base14855: state.all;
	return state.all;
}

/* ===== Recommenders ===== */
let uiLocked = false; // when true, block keyboard shortcuts during calculation
function lockUI(yes){
	uiLocked = yes;
	/* 1) Buttons: disable everything except Stop */
	document.querySelectorAll('.btn').forEach(b => {
		if (b.id !== 'stopBtn') b.disabled = yes; // Disable all buttons except the Stop button
	});
	const stop = byId('stopBtn');
	if (stop) stop.disabled = !yes;  // Stop stays enabled during calculation
	/* 2) Inputs/toggles to freeze while computing */
	['wordListSelect','hardMode','candsThreshold','poolThreshold','poolSelect','analyzeInput'].forEach(id=>{
		const el = byId(id);
		if (el) el.disabled = yes;
	});
	/* 3) Mouse clicks off for the letter keyboards only */
	['gInc','gExc','pInc','pExc','greenKeys','yellowKeys','grayKeys'].forEach(id=>{
		const el = byId(id);
		if (el) el.classList.toggle('locked', yes);
	});
}
function setProgress(p){
	byId('pbar').style.width = Math.max(0,Math.min(100,p))+'%';
}
function resetSuggestions(){
	byId('suggestTable').innerHTML='';
	byId('suggestStatus').textContent='';
	setProgress(0);
	state.cancel=false;
	lastSuggestRows = []; // Clear previous results
	const inputs = document.querySelectorAll('input[type="number"]');
	inputs.forEach(input => {
		input.value = input.defaultValue; // Reset to the original value
	});
	byId('suggestStatus').textContent = 'Results have been reset.'; // Provide feedback to the user
}

/* Build a capped guess pool: top-K from S + top-N from external (by cheap pre-score) */
async function buildGuessPoolCapped(S) {
	const hard = byId('hardMode').checked;
	const n = S.length;
	/* Hard Mode On: Search Cands Thr by Entropy */
	if (hard) {
		const candsThr = Math.max(1, Number(byId('candsThreshold').value) || n);
		const scoredS = [];
		for (const g of S) {
			const met = entropyAndExpectedSize(S, g);
			scoredS.push({
				g, score: met.entropy, expected: met.expected
			});
		}
		scoredS.sort((a, b) => (b.score - a.score) || (a.expected - b.expected));
		const topS = scoredS.slice(0, Math.min(candsThr, scoredS.length)).map(x => x.g);
		return topS;
	}
	/* Hard Mode Off */
	const ext = await getExternalPool();
	if (!ext || ext.length === 0) {
		console.warn("No external pool found, proceeding with only filtered candidates.");
	}
	const K = Math.max(1, Number(byId('candsThreshold').value) || S.length); // Candidates threshold
	const N = Math.max(0, Number(byId('poolThreshold').value) || 0);        // Pool threshold
	/* Cheap metric: entropy + tie-break by expected size */
	function cheapScoreFor(word, set) {
		const met = entropyAndExpectedSize(set, word);
		return {
			score: met.entropy, expected: met.expected
		};
	}
	/* ===== Rank S by cheap score, keep top-K ===== */
	const scoredS = [];
	for (const g of S) {
		const { score, expected } = cheapScoreFor(g, S);
		scoredS.push({ 
			g, score, expected 
		});
	}
	scoredS.sort((a, b) => (b.score - a.score) || (a.expected - b.expected));
	const topS = scoredS.slice(0, Math.min(K, scoredS.length)).map(x => x.g);
	/* ===== Rank external by cheap score against S, keep top-N ===== */
	const baseSet = new Set(S);
	const scoredExt = [];
	if (N > 0) {
		for (const g of ext) {
			if (baseSet.has(g)) continue;
			const { score, expected } = cheapScoreFor(g, S);
			scoredExt.push({
				g, score, expected
			});
		}
		scoredExt.sort((a, b) => (b.score - a.score) || (a.expected - b.expected));
	}
	const topExt = (N > 0) ? scoredExt.slice(0, Math.min(N, scoredExt.length)).map(x => x.g) : [];
	return [...topS, ...topExt]; // Final capped pool = top-K from S + top-N from external	  
}

/* One-lookahead E[steps] using the local partitionByPattern(S, guess) */
function EstepsOneLookaheadLocal(S, g) {
	const n = S.length;
	const parts = partitionByPattern(S, g);
	let est = 0;
	for (const [pat, arr] of parts.entries()) {
		const p = arr.length / n;
		if (pat === '22222') {
			est += p * 1; // Solved now: takes 1 step (this guess)
		} else {
			/* Choose best next guess g2 inside arr, then approximate the leaf */
			let best = Infinity;
			for (const g2 of arr) {
				const parts2 = partitionByPattern(arr, g2);
				let e2 = 0;
				for (const [pat2, arr2] of parts2.entries()) {
					const p2 = arr2.length / arr.length;
					if (pat2 === '22222') {
						e2 += p2 * 1; // solved next step
					} else {
						const expLeaf = (arr2.length === 1) ? 1 : 2; // tiny leaf heuristic
						e2 += p2 * (1 + expLeaf); // 1 for taking g2, plus leaf
					}
				}
				if (e2 < best) best = e2;
			}
			est += p * (1 + best); // 1 for taking g now, plus best subtree
		}
	}
	return est;
}

/* ===== Suggest Next ===== */
async function suggestNext(){
	const S = [...state.filtered];
	const n = S.length;
	const tb = byId('suggestTable'), status = byId('suggestStatus');
	tb.innerHTML='';
	setProgress(0);
	state.cancel=false;
	if(n===0){
		status.textContent='No candidates.';
		return;
	}
	lockUI(true);
	try {
		await new Promise(r=>setTimeout(r,10));
		/* Capped pool (top-K from S + top-N from external) */
		const pool = await buildGuessPoolCapped(S);
		const total = pool.length;
		const hard = byId('hardMode').checked;
		if (hard) {
			const candsThr = Math.max(1, Math.min(Number(byId('candsThreshold').value) || n, n));
			status.textContent = `Evaluating top ${candsThr} words (from filtered candidates) ...`;
		} else {
			status.textContent = `Evaluating top ${total} words (from filtered candidates and external pool) ...`;
		}
		const rows=[];
		let evaluated=0;
		for(let i=0;i<pool.length;i++){
			if(state.cancel) break;
			const g = pool[i];
			/* Compute expected steps with the local one-lookahead */
			const exp = EstepsOneLookaheadLocal(S, g);
			const met = entropyAndExpectedSize(S, g);
			rows.push({
			  word:g, esteps:exp, entropy:met.entropy, expected:met.expected, maxBucket:met.maxBucket
			});
			evaluated++;
			if((i&3)===0){
				setProgress(100*evaluated/total);
				await new Promise(r=>setTimeout(r,0));
			}
		}
		rows.sort((a,b)=> (a.esteps - b.esteps) || (b.entropy - a.entropy) || (a.expected - b.expected));
		lastSuggestRows = rows;
		lastSuggestLabel = `by Estimated E[steps]`;
		renderSuggestRows(rows, lastSuggestLabel);	
	} finally {
		lockUI(false);
		setProgress(100);
	}
}
function renderSuggestRows(rows, label){
	const tb=byId('suggestTable'); 
	const status=byId('suggestStatus');
	status.textContent = `Top 10 Words ${label}`;
	tb.innerHTML='';
	for(const r of rows.slice(0,10)){
		const tr=document.createElement('tr');
		tr.innerHTML = `
			<td class="mono">${r.word.toUpperCase()}</td>
			<td>${isFinite(r.esteps)? r.esteps.toFixed(3) : '‚Äî'}</td>
			<td>${r.entropy?.toFixed(3) ?? '‚Äî'}</td>
			<td>${r.expected?.toFixed(1) ?? '‚Äî'}</td>
			<td>${r.maxBucket ?? '‚Äî'}</td>
			`;
		tb.appendChild(tr);
	}
}

/* ===== Single-direction sorting for the suggestion table ===== */
let lastSuggestRows = [];
let lastSuggestLabel = "";
function sortRowsOneWay(rows, key) {
	const copy = rows.slice();
	const num = (v) => (typeof v === "number" ? v : Number(v));
	copy.sort((a, b) => {
		if (key === "esteps") {
			return num(a.esteps) - num(b.esteps);                // ASC
		} else if (key === "entropy") {
			return num(b.entropy) - num(a.entropy);               // DESC
		} else if (key === "expected") {
			return num(a.expected) - num(b.expected);             // ASC
		} else if (key === "maxBucket") {
			return num(a.maxBucket) - num(b.maxBucket);           // ASC
		}
		return 0;
	});
	return copy;
}
function resortSuggestTableBy(key) {
	if (!lastSuggestRows.length) return;
	const sorted = sortRowsOneWay(lastSuggestRows, key); // Sort rows based on the selected key (E[steps], entropy, etc.)
	const nice =
		key === "esteps" ? "Estimated E[steps]" :
		key === "entropy" ? "Entropy" :
		key === "expected" ? "E[cands]" :
		key === "maxBucket" ? "Max Bucket" : key;
	renderSuggestRows(sorted, `by ${nice}`);
}

/* ===== Mode wiring (Hard ‚Üî Pool) ===== */
function syncModeControls(){
	const hard = byId('hardMode').checked;
	byId('poolSelect').disabled = hard;
	byId('modeNote').textContent = hard
		? 'Hard Mode ON'
		: 'Hard Mode OFF';
}

/* ===== Wire events ===== */
function wire(){
	buildKeyboard(byId('gInc'),'gInc');
	buildKeyboard(byId('gExc'),'gExc');
	buildKeyboard(byId('pInc'),'pInc');
	buildKeyboard(byId('pExc'),'pExc');
	buildKeyboard(byId('greenKeys'),  'easyGreen');
	buildKeyboard(byId('yellowKeys'), 'easyYellow');
	buildKeyboard(byId('grayKeys'),   'easyGray');
	renderTabs();
	refresh();
	// init Easy/Pro filter mode toggle
	initFilterModeToggle();	
	byId('searchBox').oninput=e=>{
		state.search=e.target.value;
		state.searchTester=buildSearchTester(state.search);
		apply();
	};
	byId('clearAll').onclick=()=>{
		showToast("All filters have been cleared.", "info");
		state.globalInclude.clear();
		state.globalExclude.clear();
		for(let i=0;i<5;i++){
			state.pos[i].include.clear();
			state.pos[i].exclude.clear();
		}
		state.search='';
		state.searchTester=null;
		byId('searchBox').value='';
		refresh();
		apply();
	};
	/* ===== Word List Dropdown Menu Style ===== */
	const fileInput   = byId('fileInput');
	const wordSelect  = byId('wordListSelect');
	if (fileInput) {
		fileInput.onchange = async () => {
			const file = fileInput.files?.[0];
			if (!file) return;
			try {
				const text = await file.text();
				const words = parseWordsFromCsvText(text);
				if (!words.length) throw new Error('empty');
				loadWordsFromArray(words);
			} catch (e) {
				alert('Load failed: ' + e.message);
			} finally {
				fileInput.value = '';
			}
		};
	}
	if (wordSelect) {
		wordSelect.onchange = async () => {
			const v = wordSelect.value;
			try {
				if (v === 'wl2309') {
					await loadCsvFile('wordle_solutions_2309.csv');
				} else if (v === 'wl3200') {
					await loadCsvFile('wordle_solutions_3200.csv');
				} else if (v === 'wl14855') {
					await loadCsvFile('wordle_solutions_14855.csv');
					showToast(`Note: The 14,855-word list contains all valid guessable words (not necessarily answers). Recommendations may take longer to compute.`, "warn");
				} else if (v === 'custom') {
					if (fileInput) fileInput.click();
				}
			} catch (e) {
				console.error(e);
			}
		};
	}
	const btnNext = byId('suggestNext');
	if (btnNext) btnNext.onclick = () => suggestNext();
	byId('resetSuggest').onclick=()=>{
		resetSuggestions();
		showToast("All suggestion results have been cleared.", "info");
	};
	byId('stopBtn').onclick=()=>{
		state.cancel=true;
		byId('suggestStatus').textContent+=' (stopping‚Ä¶)';
		showToast("Computation stopped. Partial results are shown.", "warn");
	};
	byId('hardMode').onchange=syncModeControls;
	// byId('poolSelect').onchange=()=>{};
	// byId('wordListSelect').onchange=()=>{};
	syncModeControls();
}



/* ===== Boot ===== */
document.addEventListener('DOMContentLoaded', async function(){
	wire();
	// Disable Stop button at startup
	const stop = byId('stopBtn');
	if (stop) stop.disabled = true;
	try{
		const base = await fetchCsv('wordle_solutions_2309.csv');
		state.base2309 = base.slice();
		loadWordsFromArray(base);
		const sel = byId('wordListSelect');
		if (sel) sel.value = 'wl2309';   // sync UI with default
	} catch(e) {
		console.error(e);
	}
});

document.addEventListener("DOMContentLoaded", function() {
	/* ===== Function to toggle content visibility ===== */
	function toggleContent(sectionId) {
		const content = document.getElementById(sectionId);
		if (content.style.display === "none" || content.style.display === "") {
			content.style.display = "block"; // Show content
		} else {
			content.style.display = "none"; // Hide content
		}
	}
	/* ===== Add event listeners to each section header ===== */
	document.getElementById("wordListsToggle").addEventListener("click", function() {
	  toggleContent("wordListsContent");
	});
	document.getElementById("recommenderToggle").addEventListener("click", function() {
		toggleContent("recommenderContent");
	});
	document.getElementById("searchHelpToggle").addEventListener("click", function() {
		toggleContent("searchHelpContent");
	});
	/* document.getElementById("keyboardHintsToggle").addEventListener("click", function() {
		toggleContent("keyboardHintsContent");
	}); */
});

document.addEventListener("DOMContentLoaded", () => {
	const hSteps   = document.getElementById("sort-steps");
	const hEntropy = document.getElementById("sort-entropy");
	const hCands   = document.getElementById("sort-cands");
	const hBucket  = document.getElementById("sort-bucket");
	if (hSteps)   hSteps.addEventListener("click",   () => resortSuggestTableBy("esteps"));
	if (hEntropy) hEntropy.addEventListener("click", () => resortSuggestTableBy("entropy"));
	if (hCands)   hCands.addEventListener("click",   () => resortSuggestTableBy("expected"));
	if (hBucket)  hBucket.addEventListener("click",  () => resortSuggestTableBy("maxBucket"));
});

/* ===== Analyze Word Logic ===== */
(function(){
	function getCandidates(){
		try{
			if (window.state && Array.isArray(window.state.filtered) && window.state.filtered.length){
				return window.state.filtered.slice();			  
			}
			if (window.state && Array.isArray(window.state.all) && window.state.all.length){
				return window.state.all.slice();
			}
		} catch(e) {}
		var lis = Array.from(document.querySelectorAll('#words li'));
		if(lis.length) return lis.map(li=>li.textContent.trim().toLowerCase()).filter(w=>/^[a-z]{5}$/.test(w));
		return [];
	}
	function entropyOf(guess, set){
		const map = partitionByPattern(set, guess);
		const N = set.length;
		let H = 0;
		let maxb = 0;
		let expSize = 0;
		for(const arr of map.values()){
			const m = arr.length;
			const p = m / N;
			maxb = Math.max(maxb, m);
			if(p>0){
				H += -p * Math.log2(p);
			}
			expSize += m*m / N;
		}
		return {
			entropy:H, expected:expSize, maxBucket:maxb, buckets:map
		};
	}
	function EstepsOneLookahead(guess, set){
		const part = partitionByPattern(set, guess);
		const N = set.length;
		let est = 0;
		for (const [pat, subset] of part.entries()){
			const m = subset.length;
			const p = m/N;
			if (pat === '22222'){
				est += p * 1;  // exact hit: 1 step (this guess)
			} else {
				let best = Infinity;
				for (const g2 of subset){
					const part2 = partitionByPattern(subset, g2);
					let e2 = 0;
					for (const [pat2, subset2] of part2.entries()){
						const m2 = subset2.length;
						const p2 = m2/subset.length;
						if (pat2 === '22222') {
							e2 += p2 * 1;
						} else {
							const expLeaf = (m2===1) ? 1 : 2;
							e2 += p2 * (1 + expLeaf);
						}
					}
					if (e2 < best) best = e2;
				}
				est += p * (1 + best);
			}
		}
		return est;
	}
	function analyzeWord(word, set){
		word = (word||'').toLowerCase();
		if(!/^[a-z]{5}$/.test(word)) {
			return {
				error:'Please enter a 5-letter word (A‚ÄìZ).'
			};
		}
		if(!set || !set.length) {
			return {
				error:'No candidates loaded.'
			};
		}
		const fast = entropyOf(word, set);
		let esteps = null;
		try {
			esteps = EstepsOneLookahead(word, set);
		} catch(e) {
			esteps = null;
		}
		return {
			word, esteps, entropy:fast.entropy, expected:fast.expected, maxBucket:fast.maxBucket
		};
	}
	function renderAnalyzeRow(result){
		const tbody = document.getElementById('analyzeTable');
		if(!tbody) return;
		tbody.innerHTML = '';
		if(result.error){
			const tr = document.createElement('tr');
			const td = document.createElement('td');
			td.colSpan = 5;
			td.textContent = result.error;
			tr.appendChild(td);
			tbody.appendChild(tr);
			return;
		}
		const tr = document.createElement('tr');
		const fmt = (x)=> (x==null? '‚Äî' : (Math.round(x*1000)/1000));
		const cells = [
			result.word.toUpperCase(),
			(result.esteps==null? '‚Äî' : fmt(result.esteps)),
			fmt(result.entropy),
			fmt(result.expected),
			String(result.maxBucket)
		];
		for(const v of cells){
			const td=document.createElement('td');
			td.textContent=v;
			tr.appendChild(td);
		}
		tbody.appendChild(tr);
	}
	function onAnalyze(){
		const set = getCandidates();
		const val = (document.getElementById('analyzeInput').value||'').trim();
		renderAnalyzeRow(analyzeWord(val, set));
	}
	document.addEventListener('DOMContentLoaded', function(){
		const btn = document.getElementById('analyzeBtn');
		const ipt = document.getElementById('analyzeInput');
		if(btn) btn.addEventListener('click', onAnalyze);
		if(ipt){
			['keydown','keypress','keyup'].forEach(ev=>ipt.addEventListener(ev, e=>e.stopPropagation()));
			ipt.addEventListener('keydown', (e)=>{ if(e.key==='Enter') onAnalyze(); });
		}
	});
})();

</script>

</body>
</html>
