<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Wordle Lab ‚Äì Advanced Wordle Solver & Analyzer</title>
	<meta name="description" content="Wordle Lab is an advanced Wordle solver and analyzer that recommends optimal guesses using entropy-based analysis, E[steps], E[cands], and Max Bucket metrics.">
	<meta name="keywords" content="Wordle, Wordle Solver, Wordle Helper, Wordle Analyzer, Wordle Strategy, Entropy, E[steps], E[cands], Max Bucket, Wordle Lab">
	<meta name="author" content="Jaehong Kim">
	<meta name="robots" content="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1">
	<meta name="theme-color" content="#0f1115">
	
	<!-- Open Graph (for Facebook, LinkedIn, etc.) -->
	<meta property="og:title" content="Wordle Lab ‚Äì Advanced Wordle Solver & Analyzer">
	<meta property="og:description" content="Wordle Lab is an advanced Wordle solver and analyzer that recommends optimal guesses using entropy-based analysis, E[steps], E[cands], and Max Bucket metrics.">
	<meta property="og:url" content="https://wordlelab.com/">
	<meta property="og:type" content="website">
	<meta property="og:image" content="https://wordlelab.com/preview.png">
	
	<!-- Twitter Card -->
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="Wordle Lab ‚Äì Advanced Wordle Solver & Analyzer">
	<meta name="twitter:description" content="Wordle Lab is an advanced Wordle solver and analyzer that recommends optimal guesses using entropy-based analysis, E[steps], E[cands], and Max Bucket metrics.">
	<meta name="twitter:image" content="https://wordlelab.com/preview.png">
	<meta name="twitter:site" content="@DrDrTwice">
	
	<!-- Canonical URL -->
	<link rel="canonical" href="https://wordlelab.com/">
	
	<!-- Favicons & PWA -->
	<link href="./apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180">
	<link href="./favicon-32x32.png" rel="icon" sizes="32x32" type="image/png">
	<link href="./favicon-16x16.png" rel="icon" sizes="16x16" type="image/png">
	<link href="./site.webmanifest" rel="manifest">
	
	<!-- ===== Structured Data (JSON-LD) ===== -->
	<script type="application/ld+json">
	{
	  "@context": "https://schema.org",
	  "@type": "WebSite",
	  "name": "Wordle Lab",
	  "url": "https://wordlelab.com/",
	  "applicationCategory": "EducationalApplication",
	  "operatingSystem": "Web",
	  "description": "Wordle Lab is an advanced Wordle solver and analyzer that recommends optimal guesses using entropy-based analysis, E[steps], E[cands], and Max Bucket metrics.",
	  "inLanguage": ["en"],
	  "keywords": [
	    "Wordle lab", "Wordle helper", "Wordle analyzer", "Wordle solver", "Wordle entropy", "E[steps]", "expected candidates", "Max Bucket", "next guess recommender", "Hard Mode"
	  ],
	  "author": { "@type": "Person", "name": "Jaehong Kim" }
	}
	</script>
	
<style>
/* ===== Root theme tokens ===== */
:root{
  --bg-main:#050608;
  --bg-card:rgba(20,22,30,0.96);
  --bg-card-soft:rgba(16,18,26,0.9);
  --bg-input:#151824;
  --border:#2a3040;
  --fg:#f6f7ff;
  --sub:#9aa1c5;
  --accent:#4dd0ff;
  --accent-soft:rgba(77,208,255,0.12);
  --danger:#ff6b81;
  --btn:#202538;
  --btnHover:#2b3250;
  --shadow:0 18px 40px rgba(0,0,0,0.55);
  --overlay:radial-gradient(circle at top,#151a33 0,rgba(5,6,8,0.68) 55%,rgba(3,4,6,0.82) 100%);
  --bg-bright:0.65;
  --bg-blur:0.4px;
  --font-main:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
}

/* Light theme overrides */
body.light{
  --bg-main:#f5f6fb;
  --bg-card:rgba(255,255,255,0.96);
  --bg-card-soft:rgba(255,255,255,0.94);
  --bg-input:#f3f4fd;
  --border:#d5d8ea;
  --fg:#141624;
  --sub:#667099;
  --accent:#5c6ffb;
  --accent-soft:rgba(92,111,251,0.09);
  --danger:#e5415f;
  --btn:#e3e6fb;
  --btnHover:#d6daf8;
  --shadow:0 16px 32px rgba(15,17,25,0.16);
  --overlay:radial-gradient(circle at top,#ffffff 0,#f5f6fb 50%,#eef0fa 100%);
  --bg-bright:1;
  --bg-blur:0.6px;
}

/* Reset & base */
*,*::before,*::after{box-sizing:border-box}
html,body{
  margin:0;
  padding:0;
}
body{
  min-height:100vh;
  font-family:var(--font-main);
  background:var(--bg-main);
  color:var(--fg);
}

/* Background images (dark vs light) */
/* --- Dark Mode Background --- */
body::before{
  content:"";
  position:fixed;
  inset:0;
  background:url('./double-bubble-dark.png') center/512px repeat;
  filter:brightness(var(--bg-bright)) saturate(.95) blur(var(--bg-blur));
  z-index:-2;
  will-change: transform;
  pointer-events:none;
}
/* --- Light Mode Background --- */
body.light::before{
  content: "";
  position: fixed;
  inset: 0;
  background:url('./symphony.png') center/420px repeat;
  filter: brightness(1.25) saturate(1.05) blur(0.7px);
  z-index: -2;
  will-change: transform;
}
/* Dark overlay layer */
body::after{
  content:"";
  position:fixed;
  inset:0;
  background:var(--overlay);
  z-index:-1;
  pointer-events:none;
}
/* Light overlay layer (brighter tone) */
body.light::after {
  content: "";
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #fdfdfd 0, rgba(255,255,255,0.75) 55%, rgba(245,245,245,0.85) 100%);
  z-index: -1;
}

/* Layout wrapper */
.wrap{
  max-width:960px;
  margin:0 auto;
  padding:20px 16px 40px;
}

/* Header */
.header-row{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:12px;
  margin-bottom:14px;
}
h1{
  margin:0;
  font-size:26px;
  letter-spacing:0.03em;
}
h1 .tag{
  display:inline-block;
  margin-top:4px;
  font-size:13px;
  font-weight:400;
  color:var(--sub);
}

/* Cards & common containers */
.card{
  background:var(--bg-card);
  border-radius:16px;
  border:1px solid var(--border);
  box-shadow:var(--shadow);
  padding:12px 14px;
  backdrop-filter:blur(18px);
}
.row{
  display:flex;
  gap:12px;
  flex-wrap:wrap;
}
.list{
  max-height:220px;
  overflow:auto;
}

/* Buttons */
.btn{
  background:var(--btn);
  border:1px solid var(--border);
  color:var(--fg);
  border-radius:999px;
  padding:7px 14px;
  font-size:13px;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  gap:6px;
  transition:background .15s ease,border-color .15s ease,transform .05s ease;
}
.btn:hover{background:var(--btnHover)}
.btn:active{transform:scale(.97)}
.btn[disabled]{opacity:.55;cursor:not-allowed}

/* Top bars */
.bar{
  display:flex;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}
.bar select{
  padding:6px 8px;
  border-radius:999px;
  border:1px solid var(--border);
  background:var(--bg-input);
  color:var(--fg);
  font-size:13px;
}

/* Search input */
.search{flex:1 1 200px}
.search input{
  width:100%;
  padding:8px 10px;
  border-radius:999px;
  border:1px solid var(--border);
  background:var(--bg-input);
  color:var(--fg);
  font-size:13px;
}
.search input::placeholder{color:var(--sub);opacity:.8}

/* Letter keyboards */
.grid{
  display:grid;
  grid-template-columns:repeat(13,minmax(0,1fr));
  gap:4px;
}
.k{
  border-radius:10px;
  border:1px solid var(--border);
  padding:6px 0;
  text-align:center;
  font-size:13px;
  cursor:pointer;
  user-select:none;
  background:var(--bg-card-soft);
  color:var(--sub);
  transition:background .12s ease,border-color .12s ease,color .12s ease,transform .05s ease;
}
.k.inc{
  background:var(--accent-soft);
  border-color:var(--accent);
  color:var(--accent);
}
.k.exc{
  background:rgba(229,65,95,0.07);
  border-color:var(--danger);
  color:var(--danger);
}
.k:hover{transform:translateY(-1px)}
/* When locked (during calculation) */
.grid.locked .k{
  pointer-events:none;
  opacity:0.45;
}

/* Tabs 
.tabs{
  display:flex;
  gap:6px;
  flex-wrap:wrap;
} */
.tabs{
  display:grid;
  grid-template-columns:repeat(5, 1fr);
  gap:8px
}
.tab{
  border-radius:999px;
  border:1px solid var(--border);
  background:var(--bg-card-soft);
  color:var(--sub);
  padding:5px 10px;
  font-size:11px;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  gap:4px;
  justify-content: center;
}
.tab .num{font-weight:600}
.tab.active{
  background:var(--accent-soft);
  border-color:var(--accent);
  color:var(--accent);
}
@media(max-width:340px){
  .tab .label{display:none}
}

/* Counter */
.counter{
  margin-top:10px;
  font-size:13px;
  color:var(--sub);
}
.counter span{
  font-weight:600;
  font-size:18px;
  margin-right:3px;
}

/* Word list */
#words{
  list-style:none;
  margin:0;
  padding:0;
  columns:4 110px;
  column-gap:12px;
  font-family:"SF Mono","Roboto Mono",ui-monospace,Menlo,Monaco,monospace;
  font-size:13px;
}
#words li{
  break-inside:avoid;
  padding:1px 0;
}

/* Recommender controls */
.ctl{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
}
.ctl label{
  font-size:13px;
  color:var(--sub);
  display:flex;
  gap:6px;
  align-items:center;
}
.ctl input[type="checkbox"]{accent-color:var(--accent)}
.ctl select{
  padding:6px 8px;
  border-radius:999px;
  border:1px solid var(--border);
  background:var(--bg-input);
  color:var(--fg);
  font-size:13px;
}

/* Button row: thresholds + Suggest / Stop / Reset */
.button-container{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center;
  margin-top:8px;
}
.button-container label{
  font-size:13px;
  color:var(--sub);
  display:flex;
  align-items:center;
  gap:6px;
}
.button-container input[type="number"]{
  width:86px;
  padding:6px;
  border-radius:10px;
  border:1px solid var(--border);
  background:var(--bg-input);
  color:var(--fg);
  font-size:13px;
}
.button-container .btn{
  padding-inline:14px;
  flex:0 0 auto;
}
#space-1{
  display:none;
  flex-basis:0;
}

/* Progress bar */
.progress{
  position:relative;
  height:6px;
  border-radius:999px;
  background:rgba(255,255,255,0.06);
  overflow:hidden;
}
.progress .barin{
  position:absolute;
  inset:0;
  width:0%;
  border-radius:inherit;
  background:linear-gradient(90deg,var(--accent),#7cf3ff);
  transition:width .12s linear;
}

/* Tables */
table{
  width:100%;
  border-collapse:collapse;
  font-size:13px;
}
th,td{
  padding:6px 8px;
  text-align:left;
  border-bottom:1px solid rgba(255,255,255,0.06);
}
th{
  font-size:12px;
  text-transform:uppercase;
  letter-spacing:0.05em;
  color:var(--sub);
  background:rgba(0,0,0,0.1);
}
td{color:var(--fg)}
td.mono{
  font-family:"SF Mono","Roboto Mono",ui-monospace,Menlo,Monaco,monospace;
}
th#sort-steps,
th#sort-entropy,
th#sort-cands,
th#sort-bucket{
  cursor:pointer;
}
th#sort-steps:focus,
th#sort-entropy:focus,
th#sort-cands:focus,
th#sort-bucket:focus{
  outline:2px solid var(--accent);
  outline-offset:2px;
}

/* Help section & toggles */
.help{
  margin-top:16px;
  font-size:13px;
  color:var(--sub);
}
.help ul{
  margin:6px 0 0;
  padding-left:18px;
}
.help li{margin-bottom:4px}
.toggle-header{
  display:inline-block;
  margin-top:6px;
  cursor:pointer;
  user-select:none;
}
.toggle-header::before{
  content:"‚ñ∂";
  display:inline-block;
  margin-right:6px;
  font-size:10px;
  transform:translateY(-1px);
}
.toggle-header.open::before{
  content:"‚ñº";
}
.toggle-content{
  display:none;
  margin-top:4px;
}

/* Hints */
.hint{
  font-size:12px;
  color:var(--sub);
}

/* Analyze input */
#analyzeInput{
  min-width:120px;
}

/* Responsive tweaks */
@media(max-width:900px){
  #words{columns:3 110px}
}
@media(max-width:720px){
  /* --- Mobile adjustments (smaller blur for clarity) --- */
  body::before {
    filter: brightness(calc(var(--bg-bright) + 0.1)) saturate(.95) blur(0.6px);
  }
  body.light::before {
    filter: brightness(1.3) saturate(1.1) blur(0.5px);
  }
  .wrap{padding-inline:10px}
  .header-row{flex-direction:column;align-items:flex-start}
  #words{columns:2 110px}
}
/* Mobile: thresholds first row, buttons second row */
@media(max-width:600px){
  .button-container label{
    flex:1 1 calc(50% - 6px);
  }
  #space-1{
    display:block;
    flex-basis:100%;
    height:0;
  }
  .button-container .btn{
    flex:1 1 calc(33.3% - 6px);
    justify-content:center;
  }
}
</style>
	
  </head>
  <body>
    <div class="wrap">
	  <!-- Header -->
	  <div class="header-row">
	    <h1>
		  Wordle Lab
		  <br>
		  <span class="tag">
		    Advanced Wordle Solver & Analyzer		  
		  </span>		
		</h1>
		<button class="btn" id="modeToggle" title="Toggle Dark/Light">
		  üåô Dark
		</button>	  
	  </div>
	  <!-- Top controls -->
	  <div class="card" style="margin-bottom:12px">
	    <!-- Word List Dropdown Menu Style-->
	    <div class="bar">
		  <label for="wordListSelect" style="font-size:13px; color:var(--sub); margin-right:6px;">
		    Select Word List
		  </label>
		  <select id="wordListSelect">
		    <option value="wl2309">2309 Word List (Default)</option>
			<option value="wl3200">3200 Extended Word List</option>
			<!-- <option value="wl14855">14855 Guessable words list</option> -->
			<option value="custom">Custom Word List (Upload CSV‚Ä¶)</option>
		  </select>
		</div>
		<input id="fileInput" type="file" accept=".txt,.csv" style="display:none" />
		<!-- Word List Button Style-->
	    <!-- <div class="bar">
		  <label class="filelabel">
		    <input accept=".csv,.txt" id="fileInput" type="file">
			<button class="btn" id="chooseFileBtn">
			  Upload Custom List (CSV)
			</button>
		  </label>
		  <button class="btn" id="use2309">
		    2309 Word Pool (Default)
		  </button>
		  <button class="btn" id="use3200">
		    3200 Word Pool
		  </button>
		  <button class="btn" id="use14855">
		    14855 Word Pool
		  </button>
		</div> -->
		<div class="bar" style="margin-top:10px">
		  <div class="search">
		    <input id="searchBox" placeholder="Search (use ?, *, [AEIOU], &amp;, |, ( ) &mdash; see help below)" style="text-transform:uppercase;">
		  </div>
		  <button class="btn" id="clearAll">
		    Clear Filters
		  </button>
		</div>
	  </div>
	  <!-- Global include/exclude -->
	  <div class="row">
	    <div class="card" style="flex:1;min-width:320px">
		  <div style="margin-bottom:8px">
		    <strong>Global Include</strong>
		  </div>
		  <div class="grid" id="gInc">
		  </div>
		</div>
		<div class="card" style="flex:1;min-width:320px">
		  <div style="margin-bottom:8px">
		    <strong>Global Exclude</strong>
		  </div>
		  <div class="grid" id="gExc">
		  </div>
		</div>
	  </div>
	  <!-- Position include/exclude -->
	  <div class="card" style="margin-top:12px">
	    <div class="tabs" id="tabs">
		</div>
		<div class="row" style="margin-top:10px">
		  <div class="card" style="flex:1;min-width:280px">
		    <div style="margin-bottom:8px">
			  <strong>Position Include</strong>
			</div>
			<div class="grid" id="pInc">
			</div>
		  </div>
		  <div class="card" style="flex:1;min-width:280px">
		    <div style="margin-bottom:8px">
			  <strong>Position Exclude</strong>
			</div>
			<div class="grid" id="pExc">
			</div>
		  </div>			
		</div>	  
	  </div>
	  <!-- Counter -->
	  <div class="counter">
	    <span id="count">
		  0
		</span>
		<small>candidates</small>
	  </div>
	  <!-- List -->
	  <div class="card list" style="margin-top:6px">
	    <ul id="words">
		</ul>
	  </div>
	  <!-- Recommender -->
	  <div class="card" style="margin-top:12px">
	    <div class="bar" style="justify-content:space-between">
		  <div>
		    <strong>Next-Guess Recommender</strong>
			<span class="tag">
			  <!-- (Entropy-based) -->
			</span>
		  </div>
		</div>
		<!-- Controls: row 1 -->
		<div class="ctl" style="margin-top:10px">
		  <label title="Enforce feedback consistency (Wordle Hard Mode rules)">
		    Hard Mode
			<input id="hardMode" type="checkbox">
			</input>
		  </label>
		  <label title="Guess pool used when Hard Mode is OFF">
		    Guess Pool
			<select id="poolSelect">
			  <option selected="" value="current">
			    Current Word List
			  </option>
			  <option value="2309">
			    2309 Word List
			  </option>
			  <option value="3200">
			    3200 Word List
			  </option>
			  <option value="14855">
			    14855 Word List
			  </option>			
			</select>		  
		  </label>		
		</div>
		<!-- Controls: row 2 -->
		<div class="button-container">
		  <label id="candsLabel" title="Cap the number of candidate guesses from the main candidate list">
		    Cands Thr
			<input id="candsThreshold" min="1" type="number" value="200">
		  </label>
		  <label id="thrLabel" title="Cap the number of external guesses from the extended pool (applies only when Hard Mode is OFF)">
		    Pool Thr
			<input id="poolThreshold" min="0" type="number" value="200"/>
		  </label>
		  <span id="space-1"></span>
		  <button id="suggestNext" class="btn">
		    Suggest
		  </button>
		  <button id="stopBtn" class="btn">
		    Stop
		  </button>
		  <button id="resetSuggest" class="btn">
		    Reset
		  </button>		
		</div>
		<div class="hint" id="modeNote" style="margin-top:4px">
		  Hint
		</div>
		<!-- Progress + status -->
		<div class="progress" style="margin-top:10px">
		  <div class="barin" id="pbar">
		  </div>
		</div>
		<div class="hint" id="suggestStatus" style="margin-top:8px">
		</div>
		<!-- Table -->
		<div style="overflow:auto;margin-top:8px">
		  <table>
		    <thead>
			  <tr>
			    <th>
				  Word
				</th>
				<th id="sort-steps" role="button" tabindex="0" title="Click to show the Top 10 by E[steps] (smaller is better)">
				  E[steps]
				</th>
				<th id="sort-entropy" role="button" tabindex="0" title="Click to show the Top 10 by Entropy (higher is better)">
				  Entropy
				</th>
				<th id="sort-cands" role="button" tabindex="0" title="Click to show the Top 10 by E[cands] (smaller is better)">
				  E[cands]
				</th>
				<th id="sort-bucket" role="button" tabindex="0" title="Click to show the Top 10 by Max Bucket (smaller is better)">
				  Max Bucket
				</th>
			  </tr>
			</thead>
			<tbody id="suggestTable">
			</tbody>		  
		  </table>		
		</div>	  
	  </div>
	  <!-- Analyze Word -->
	  <div class="card" id="analyzeCard" style="margin-top:12px">
	    <div class="bar" style="justify-content:space-between; gap:8px;">
		  <div>
		    <strong>Analyze Word</strong>
			<span class="tag">
			  <!-- (w.r.t. current candidate list) -->
			</span>		  
		  </div>
		  <div class="bar" style="gap:6px;">
		    <input id="analyzeInput" maxlength="5" placeholder="5-letter word" style="text-transform:uppercase;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:var(--input);color:var(--fg)">
			<button class="btn" id="analyzeBtn">
			  Analyze
			</button>
		  </div>		
		</div>
		<div style="overflow:auto;margin-top:10px">
		  <table>
		    <thead>
			  <tr>
			    <th>
				  Word
				</th>
				<th>
				  E[steps]
				</th>
				<th>
				  Entropy
				</th>
				<th>
				  E[cands]
				</th>
				<th>
				  Max Bucket
				</th>
			  </tr>
			</thead>
			<tbody id="analyzeTable">
			</tbody>
		  </table>		
		</div>	  
	  </div>
	  <!-- Help -->
	  <div class="help">
	    <!-- Word Lists for Wordle -->
	    <strong id="wordListsToggle" class="toggle-header">Word Lists for Wordle</strong>
		<div id="wordListsContent" class="toggle-content">
		  <p>Here are three commonly referenced word lists associated with the game Wordle: the ‚Äú2309‚Äù, ‚Äú3200‚Äù, and ‚Äú14855‚Äù word lists. None of these lists have been officially confirmed as the definitive answer sets by the creators of Wordle.</p>
		  <ul>
		    <li>
			  <strong>2309 Word List</strong>: <p>Many players report seeing answers from this 2,309‚Äëword list, though there are exceptions.</p>
			</li>
			<li>
			  <strong>3200 Word List</strong>: <p>The 3,200‚Äëword list is often used as a broader ‚Äúanswers‚Äù list in community tools.</p>
			</li>
			<li>
			  <strong>14855 Word List</strong>: <p>This much larger list, containing 14,855 words, is believed to reflect the broader vocabulary of words accepted by the game as guesses (rather than necessarily as answers).</p>
			</li>
		  </ul>
		  <p>Each of these lists plays a different role: the 2309 list as a common answers reference, the 3200 list for extended answer coverage, and the 14855 list for comprehensive guess vocabulary.</p>		
		</div>
		<br>
		<!-- Next-Guess Recommender Help -->
		<strong id="recommenderToggle" class="toggle-header">Next-Guess Recommender Help</strong>
		<div id="recommenderContent" class="toggle-content">
		  <ul>
		    <br>
			<li>
			  <strong>Next-Guess Recommender</strong>: This tool uses an <strong>entropy-based</strong> approach to narrow down the list of candidate guesses. Initially, it ranks words based on their <strong>entropy</strong>, which measures the uncertainty or information content of the words. After narrowing down the candidates using entropy, other factors such as <strong>E[steps]</strong>, <strong>E[cands]</strong>, and <strong>max bucket</strong> are used to further refine the recommendations.
			</li>
			<br>
		    <li>
			  <strong>ENTROPY</strong>: A measure of uncertainty, where higher values indicate words with more potential for narrowing down the solution space. Entropy values represent how "informative" a word is when used as a guess.
			</li>		  
		    <li>
			  <strong>E[STEPS]</strong>: An estimate of the number of steps required to guess the target word, given the current pool of candidate words. This is an approximation and may not always be 100% accurate.
			</li>		  
		    <li>
			  <strong>E[CANDS]</strong>: The expected number of candidates remaining after a guess, based on the current word pool. This metric helps assess how effective a guess is in reducing the search space.
			</li>		  
		    <li>
			  <strong>MAX BUCKET</strong>: The size of the largest group of words that would result from guessing a particular word, given the current state of the game. This value helps identify words that will divide the remaining possibilities evenly.
			</li>
 			<br> 
		    <li>
			  <strong>Hard Mode ON</strong>: Guesses are made only from the top-ranked (Cands Thr) candidates based on entropy.
			</li>		  
		    <li>
			  <strong>Hard Mode OFF</strong>: Guesses are made from both the top-ranked (Cands Thr) candidates and top-ranked words from the external pool (Pool Thr), based on entropy.
			</li>
		    <li>
			  <strong>Cands Thr (Candidates Threshold)</strong>: The maximum number of top-ranked candidate guesses from the main candidate list, selected based on entropy, used for the recommendation.
			</li>
		    <li>
			  <strong>Pool Thr (Pool Threshold)</strong>: The maximum number of top-ranked external pool guesses, selected based on entropy, used for the recommendation (only applies when Hard Mode is OFF).
			</li>			
		  </ul>		
		</div>
		<br>
		<!-- Search Help -->
		<strong id="searchHelpToggle" class="toggle-header">Search Help</strong>
		<div id="searchHelpContent" class="toggle-content">
		  <ul>
		    <li>
			  <strong>?</strong>: Exactly one letter (e.g.,<code>A?E</code>&rarr;<em>ACE, APE, ARE</em>)
			</li>
			<li>
			  <strong>*</strong>: Zero or more letters (e.g.,<code>E*E</code>&rarr;<em>AGREE, EAGLE, EERIE</em>)
			</li>
			<li>
			  <strong>[AEIOU]</strong>: Any one listed; <strong>[^AEIOU]</strong>: Not these (e.g.,<code>[^AEIOU]ATE</code>&rarr;<em>SLATE, CRATE</em>)
			</li>
			<li>
			  <strong>&amp;</strong>: AND; <strong>|</strong>: OR (AND has higher precedence)
			</li>
			<li>
			  <strong>( )</strong>: Group terms (e.g.,<code>(ING &amp; R) | (A?E &amp; N)</code>)
			</li>
		  </ul>		
		</div>
		<br>
		<!-- Shortccut Keys -->
		<strong id="keyboardHintsToggle" class="toggle-header">Shortcut Keys</strong>
		<div id="keyboardHintsContent" class="toggle-content">
		  <ul>
		    <li>
			  <strong>Letter</strong>: Global Include
			</li>
			<li>
			  <strong>Alt+Letter</strong>: Global Exclude
			</li>
			<li>
			  <strong>Shift+Letter</strong>: Position Include
			</li>
			<li>
			  <strong>Ctrl+Letter</strong>: Position Exclude
			</li>
			<li>
			  <strong>1&ndash;5</strong>: Switch Tab
			</li>
			<li>
			  <strong>/</strong>: Search
			</li>
			<li>
			  <strong>@</strong>: Analyze Word
			</li>
			<li>
			  <strong>`</strong>: Theme
			</li>
		  </ul>		
		</div>	  
	  </div>	  
	</div>
	<script>

	  /* ===== Utilities & State ===== */
	  const byId=id=>document.getElementById(id);
	  const ALPHA=Array.from({length:26},(_,i)=>String.fromCharCode(65+i));
	  const state={
	    all:[], filtered:[], search:'',
		searchTester:null,
		globalInclude:new Set(), globalExclude:new Set(),
		pos:Array.from({length:5},()=>({include:new Set(),exclude:new Set()})),
		activePos:0,
		base2309:[], base3200:[], base14855:[],
		cancel:false
	  };
	
	  /* ===== Theme ===== */
	  (function(){
	    const s=localStorage.getItem('wf-theme');
		if(s==='light')document.body.classList.add('light');
		updateThemeBtn(); byId('modeToggle').onclick=toggleTheme;
	  })();
	  function toggleTheme(){
	    document.body.classList.toggle('light');
		localStorage.setItem('wf-theme',document.body.classList.contains('light')?'light':'dark');
		updateThemeBtn();
	  }
	  function updateThemeBtn(){
	    byId('modeToggle').textContent=document.body.classList.contains('light')?'‚òÄÔ∏è Light':'üåô Dark';
	  }
  	  	  
	  /* ===== CSV parsing & loading ===== */
	  function parseWordsFromCsvText(t){
	    const lines=t.split(/\r?\n/);const words=[];const seen=new Set();
		for(const raw of lines){
		  const line=raw.trim(); if(!line) continue;
		  const cells=line.split(/,|\s+/);
		  for(let c of cells){
		    c=(c||'').trim().toLowerCase();
			if(/^[a-z]{5}$/.test(c)&&!seen.has(c)){ seen.add(c); words.push(c); }
		  }
		}
		return words;
	  }
	  async function fetchCsv(name){
	    const res=await fetch(`./${name}`,{cache:'no-store'});
		if(!res.ok) throw new Error('fetch failed: '+name);
		return parseWordsFromCsvText(await res.text());
	  }
	  async function loadCsvFile(name){
	    try{
		  lockUI(true);
		  const words=await fetchCsv(name);
		  loadWordsFromArray(words);
		} catch(e) { alert('Error loading '+name+': '+e.message); }
		finally{ lockUI(false); }
	  }
	  
	  /* ===== Keyboards & Tabs ===== */
	  function buildKeyboard(container,kind){
	    container.innerHTML='';
		for(const ch of ALPHA){
		  const d=document.createElement('div');
		  d.className='k'; d.textContent=ch; d.dataset.ch=ch.toLowerCase();
		  d.onclick=()=>{
		    if(kind==='gInc')toggle(state.globalInclude,state.globalExclude,d.dataset.ch);
			else if(kind==='gExc')toggle(state.globalExclude,state.globalInclude,d.dataset.ch);
			else if(kind==='pInc')toggle(state.pos[state.activePos].include,state.pos[state.activePos].exclude,d.dataset.ch);
			else toggle(state.pos[state.activePos].exclude,state.pos[state.activePos].include,d.dataset.ch);
			refresh(); apply();
		  };
		  container.appendChild(d);
		}
	  }
	  function toggle(primary,secondary,ch){
	    if(primary.has(ch)) primary.delete(ch); else { primary.add(ch); secondary.delete(ch); }
	  }
	  function refresh(){
	    const gI=byId('gInc').children, gE=byId('gExc').children, pI=byId('pInc').children, pE=byId('pExc').children;
		for(const e of gI) e.classList.toggle('inc',state.globalInclude.has(e.dataset.ch));
		for(const e of gE) e.classList.toggle('exc',state.globalExclude.has(e.dataset.ch));
		for(const e of pI) e.classList.toggle('inc',state.pos[state.activePos].include.has(e.dataset.ch));
		for(const e of pE) e.classList.toggle('exc',state.pos[state.activePos].exclude.has(e.dataset.ch));
		for(const t of byId('tabs').children) t.classList.toggle('active',Number(t.dataset.idx)===state.activePos);
	  }
	  function renderTabs(){
	    const tabs=byId('tabs'); tabs.innerHTML='';
		for(let i=0;i<5;i++){
		  const b=document.createElement('button');
		  b.className='tab'+(i===state.activePos?' active':'');
		  b.innerHTML='<span class="label">Pos </span><span class="num">'+(i+1)+'</span>';
		  b.dataset.idx=i; b.onclick=()=>{ state.activePos=i; refresh(); };
		  tabs.appendChild(b);
		}
	  }
	  
	  /* ===== Search expression ===== */
	  function sanitizeClassContent(s){
	    const x=s.toLowerCase().replace(/\s+/g,'');
		if(!/^[a-z\-\^]*$/.test(x)) return null;
		return x;
	  }
	  function escapeRe(s){
	    return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
	  }
	  function buildRegexFromMiniPattern(q){
	    let reStr='';
		for(let i=0;i<q.length;i++){
		  const ch=q[i];
		  if(ch==='*'){
		    let j=i;
			while(j<q.length&&q[j]==='*') j++;
			reStr+='[a-z]*';
			i=j-1;
		  } else if(ch==='?'){
		    reStr+='[a-z]';
		  } else if(ch==='['){
		    let j=i+1;
			while(j<q.length&&q[j]!==']') j++;
		    if(j<q.length){
			  const s=q.slice(i+1,j);
			  const ok=sanitizeClassContent(s);
			  if(ok!==null){
			    reStr+=`[${ok}]`;
				i=j;
			  } else reStr+='\\[';
			} else reStr+='\\[';
		  } else if(ch===' '){
		    /* ignore */
		  } else if(/[a-z]/.test(ch)){
		    reStr+=ch;
		  } else reStr+=escapeRe(ch);
		}
		return new RegExp(reStr);
	  }
	  function tokenize(expr){
	    const s=(expr||'').toLowerCase();
		const out=[];
		let i=0;
		const isOp=c=>c==='|'||c==='&';
		while(i<s.length){
		  const c=s[i];
		  if(c===' '){
		    i++;
			continue;
		  }
		  if(c==='('||c===')'||isOp(c)){
		    out.push({type:c});
			i++;
			continue;
		  }
		  let buf='';
		  while(i<s.length){
		    const ch=s[i];
			if(ch==='('||ch===')'||isOp(ch)||ch===' ') break;
			if(ch==='['){
			  let j=i+1;
			  while(j<s.length&&s[j]!==']') j++;
			  if(j<s.length){
			    buf+=s.slice(i,j+1);
				i=j+1;
				continue;
			  } else {
			    buf+='[';
				i++;
				continue;
			  }
			}
			buf+=ch; i++;
		  } out.push({type:'pat',value:buf});
		} return out;
	  }
	  function toRPN(tokens){
	    const out=[], st=[];
		const prec=t=>t.type==='&'?2:(t.type==='|'?1:0);
		const isOp=t=>t.type==='|'||t.type==='&';
		for(const t of tokens){
		  if(t.type==='pat') out.push(t);
		  else if(isOp(t)){
		    while(st.length){
			  const top=st[st.length-1];
			  if(isOp(top)&&prec(top)>=prec(t)) out.push(st.pop());
			  else break;
			}
			st.push(t);
		  } else if(t.type==='(') st.push(t);
		  else if(t.type===')'){
		    while(st.length&&st[st.length-1].type!=='(') out.push(st.pop());
			if(st.length&&st[st.length-1].type==='(') st.pop();
		  }
		}
		while(st.length){
		  const x=st.pop();
		  if(x.type!=='('&&x.type!==')') out.push(x); 
		} return out;
	  }
	  function buildTesterFromRPN(rpn){
	    const st=[]; 
		for(const t of rpn){
		  if(t.type==='pat'){
		    const re=buildRegexFromMiniPattern(t.value);
			st.push(w=>re.test(w));
		  } else if(t.type==='&'||t.type==='|'){
		    const b=st.pop(), a=st.pop();
			if(!a||!b) return null;
			st.push(t.type==='&'?(w)=>a(w)&&b(w):(w)=>a(w)||b(w));
		  }
		}
		return st.length===1?st[0]:null;
	  }
	  function buildSearchTester(expr){
	    const toks=tokenize(expr);
		if(!toks.some(t=>t.type==='pat')) return null;
		const rpn=toRPN(toks);
		const tester=buildTesterFromRPN(rpn);
		return tester||null;
	  }
	  
	  /* ===== Filter & list ===== */
	  function apply(){
	    const out=[];
		const gi=state.globalInclude, ge=state.globalExclude;
		const tester=state.searchTester;
		WORDS: for(const w of state.all){
		  if(tester && !tester(w)) continue;
		  for(const ch of ge) if(w.includes(ch)) continue WORDS;
		  for(const ch of gi) if(!w.includes(ch)) continue WORDS;
		  for(let i=0;i<5;i++){
		    const need=state.pos[i].include, ban=state.pos[i].exclude, c=w[i];
			if(need.size>0 && !need.has(c)) continue WORDS;
			if(ban.has(c)) continue WORDS;
		  }
		  out.push(w);
		}
		state.filtered=out; renderList();
	  }
	  function renderList(){
	    const ul=byId('words');
		ul.innerHTML='';
		for(const w of state.filtered){
		  const li=document.createElement('li');
		  li.textContent=w.toUpperCase();
		  ul.appendChild(li);
		}
		byId('count').textContent=state.filtered.length;
	  }
	  function loadWordsFromArray(a){
	    const seen=new Set();
		state.all=a.filter(w=>/^[a-z]{5}$/.test(w)&&!seen.has(w)&&seen.add(w)).sort(); apply();
	  }
	  
	  /* ===== Wordle feedback ===== */
	  function pattern(guess, answer){
	    const g=[...guess], a=[...answer];
		const res=Array(5).fill('0');
		const cnt={};
		for(let i=0;i<5;i++){
		  if(a[i]===g[i]){
		    res[i]='2';
		  } else {
		    cnt[a[i]]=(cnt[a[i]]||0)+1;
		  }
		}
		for(let i=0;i<5;i++){
		  if(res[i]==='2') continue;
		  const ch=g[i];
		  if(cnt[ch]>0){
		    res[i]='1';
			cnt[ch]--;
		  }
		}
		return res.join('');
	  }
	  function partitionByPattern(S, guess){
	    const map=new Map();
		for(const ans of S){
		  const p=pattern(guess, ans);
		  let arr=map.get(p);
		  if(!arr){
		    arr=[];
			map.set(p,arr);
		  }
		  arr.push(ans);
		}
		return map;
	  }
	  function entropyAndExpectedSize(S, guess){
	    const parts=partitionByPattern(S, guess);
		const n=S.length;
		let H=0, exp=0, maxb=0;
		for(const arr of parts.values()){
		  const p=arr.length/n;
		  H += -p*Math.log2(p);
		  exp += p*arr.length;
		  if(arr.length>maxb) maxb=arr.length;
		}
		return {
		  entropy:H, expected:exp, maxBucket:maxb
		};
	  }
	  
	  /* ===== External pools (lazy load) ===== */
	  async function ensurePoolLoaded(which){
	    if(which==='2309' && !state.base2309.length){
		  state.base2309 = await fetchCsv('wordle_solutions_2309.csv');
		}
		if(which==='3200' && !state.base3200.length){
		  state.base3200 = await fetchCsv('wordle_solutions_3200.csv');
		}
		if(which==='14855'&& !state.base14855.length){
		  state.base14855= await fetchCsv('wordle_solutions_14855.csv');
		}
	  }
	  async function getExternalPool(){
	    const sel=byId('poolSelect').value;
		if(sel==='current') return state.all;        // current loaded list
		await ensurePoolLoaded(sel);
		if(sel==='2309')  return state.base2309.length? state.base2309 : state.all;
		if(sel==='3200')  return state.base3200.length? state.base3200 : state.all;
		if(sel==='14855') return state.base14855.length? state.base14855: state.all;
		return state.all;
	  }
	  
	  /* ===== Recommenders ===== */
	  let uiLocked = false; // when true, block keyboard shortcuts during calculation
	  function lockUI(yes){
	    uiLocked = yes;
		/* 1) Buttons: disable everything except Stop */
		document.querySelectorAll('.btn').forEach(b => {
		  if (b.id !== 'stopBtn') b.disabled = yes; // Disable all buttons except the Stop button
		});
		const stop = byId('stopBtn');
		if (stop) stop.disabled = !yes;  // Stop stays enabled during calculation
		/* 2) Inputs/toggles to freeze while computing */
		['wordListSelect','hardMode','candsThreshold','poolThreshold','poolSelect','analyzeInput'].forEach(id=>{
		  const el = byId(id);
		  if (el) el.disabled = yes;
		});
		/* 3) Mouse clicks off for the letter keyboards only */
		['gInc','gExc','pInc','pExc'].forEach(id=>{
		  const el = byId(id);
		  if (el) el.classList.toggle('locked', yes);
		});
	  }
	  function setProgress(p){
	    byId('pbar').style.width = Math.max(0,Math.min(100,p))+'%';
	  }
	  function resetSuggestions(){
	    byId('suggestTable').innerHTML='';
		byId('suggestStatus').textContent='';
		setProgress(0);
		state.cancel=false;
		lastSuggestRows = []; // Clear previous results
		const inputs = document.querySelectorAll('input[type="number"]');
		inputs.forEach(input => {
		  input.value = input.defaultValue; // Reset to the original value
		});
		byId('suggestStatus').textContent = 'Results have been reset.'; // Provide feedback to the user
	  }
	  
	  /* Build a capped guess pool: top-K from S + top-N from external (by cheap pre-score) */
	  async function buildGuessPoolCapped(S) {
	    const hard = byId('hardMode').checked;
		const n = S.length;
		/* Hard Mode On: Search Cands Thr by Entropy */
		if (hard) {
		  const candsThr = Math.max(1, Number(byId('candsThreshold').value) || n);
		  const scoredS = [];
		  for (const g of S) {
		    const met = entropyAndExpectedSize(S, g);
			scoredS.push({ g, score: met.entropy, expected: met.expected });
		  }
		  scoredS.sort((a, b) => (b.score - a.score) || (a.expected - b.expected));
		  const topS = scoredS.slice(0, Math.min(candsThr, scoredS.length)).map(x => x.g);
		  return topS;
		}
		/* Hard Mode Off */
		const ext = await getExternalPool();
		if (!ext || ext.length === 0) {
		  console.warn("No external pool found, proceeding with only filtered candidates.");
		}
		const K = Math.max(1, Number(byId('candsThreshold').value) || S.length); // Candidates threshold
		const N = Math.max(0, Number(byId('poolThreshold').value) || 0);        // Pool threshold
		/* Cheap metric: entropy + tie-break by expected size */
		function cheapScoreFor(word, set) {
		  const met = entropyAndExpectedSize(set, word);
		  return {
		    score: met.entropy, expected: met.expected
		  };
		}
		/* ===== Rank S by cheap score, keep top-K ===== */
		const scoredS = [];
		for (const g of S) {
		  const { score, expected } = cheapScoreFor(g, S);
		  scoredS.push({ 
		    g, score, expected 
		  });
		}
		scoredS.sort((a, b) => (b.score - a.score) || (a.expected - b.expected));
		const topS = scoredS.slice(0, Math.min(K, scoredS.length)).map(x => x.g);
		/* ===== Rank external by cheap score against S, keep top-N ===== */
		const baseSet = new Set(S);
		const scoredExt = [];
		if (N > 0) {
		  for (const g of ext) {
		    if (baseSet.has(g)) continue;
			const { score, expected } = cheapScoreFor(g, S);
			scoredExt.push({ g, score, expected });
		  }
		  scoredExt.sort((a, b) => (b.score - a.score) || (a.expected - b.expected));
		}
		const topExt = (N > 0) ? scoredExt.slice(0, Math.min(N, scoredExt.length)).map(x => x.g) : [];
		return [...topS, ...topExt]; // Final capped pool = top-K from S + top-N from external	  
	  }
	  
	  /* One-lookahead E[steps] using the local partitionByPattern(S, guess) */
	  function EstepsOneLookaheadLocal(S, g) {
	    const n = S.length;
		const parts = partitionByPattern(S, g);
		let est = 0;
		for (const [pat, arr] of parts.entries()) {
		  const p = arr.length / n;
		  if (pat === '22222') {
		    est += p * 1; // Solved now: takes 1 step (this guess)
		  } else {
		    /* Choose best next guess g2 inside arr, then approximate the leaf */
			let best = Infinity;
			for (const g2 of arr) {
			  const parts2 = partitionByPattern(arr, g2);
			  let e2 = 0;
			  for (const [pat2, arr2] of parts2.entries()) {
			    const p2 = arr2.length / arr.length;
				if (pat2 === '22222') {
				  e2 += p2 * 1; // solved next step
				} else {
				  const expLeaf = (arr2.length === 1) ? 1 : 2; // tiny leaf heuristic
				  e2 += p2 * (1 + expLeaf); // 1 for taking g2, plus leaf
				}
			  }
			  if (e2 < best) best = e2;
			}
			est += p * (1 + best); // 1 for taking g now, plus best subtree
		  }
		}
		return est;
	  }
	  
	  /* ===== Suggest Next ===== */
	  async function suggestNext(){
	    const S = [...state.filtered];
		const n = S.length;
		const tb = byId('suggestTable'), status = byId('suggestStatus');
		tb.innerHTML='';
		setProgress(0);
		state.cancel=false;
		if(n===0){
		  status.textContent='No candidates.';
		  return;
		}
		lockUI(true);
		try {
		  await new Promise(r=>setTimeout(r,10));
		  /* Capped pool (top-K from S + top-N from external) */
		  const pool = await buildGuessPoolCapped(S);
		  const total = pool.length;
		  const hard = byId('hardMode').checked;
		  if (hard) {
		    const candsThr = Math.max(1, Math.min(Number(byId('candsThreshold').value) || n, n));
			status.textContent = `Evaluating top ${candsThr} words (from filtered candidates) ...`;
		  } else {
		    status.textContent = `Evaluating top ${total} words (from filtered candidates and external pool) ...`;
		  }
		  const rows=[];
		  let evaluated=0;
		  for(let i=0;i<pool.length;i++){
		    if(state.cancel) break;
			const g = pool[i];
			/* Compute expected steps with the local one-lookahead */
			const exp = EstepsOneLookaheadLocal(S, g);
			const met = entropyAndExpectedSize(S, g);
			rows.push({
			  word:g, esteps:exp, entropy:met.entropy, expected:met.expected, maxBucket:met.maxBucket
			});
			evaluated++;
			if((i&3)===0){
			  setProgress(100*evaluated/total);
			  await new Promise(r=>setTimeout(r,0));
			}
		  }
		  rows.sort((a,b)=> (a.esteps - b.esteps) || (b.entropy - a.entropy) || (a.expected - b.expected));
		  lastSuggestRows = rows;
		  lastSuggestLabel = `by Estimated E[steps]`;
		  renderSuggestRows(rows, lastSuggestLabel);	
		} finally {
		  lockUI(false);
		  setProgress(100);
		}
	  }
	  function renderSuggestRows(rows, label){
	    const tb=byId('suggestTable'); 
		const status=byId('suggestStatus');
		status.textContent = `Top 10 Words ${label}`;
		tb.innerHTML='';
		for(const r of rows.slice(0,10)){
		  const tr=document.createElement('tr');
		  tr.innerHTML = `
		    <td class="mono">${r.word.toUpperCase()}</td>
			<td>${isFinite(r.esteps)? r.esteps.toFixed(3) : '‚Äî'}</td>
			<td>${r.entropy?.toFixed(3) ?? '‚Äî'}</td>
			<td>${r.expected?.toFixed(1) ?? '‚Äî'}</td>
			<td>${r.maxBucket ?? '‚Äî'}</td>
		  `;
		  tb.appendChild(tr);
		}
	  }
	  
	  /* ===== Single-direction sorting for the suggestion table ===== */
	  let lastSuggestRows = [];
	  let lastSuggestLabel = "";
	  function sortRowsOneWay(rows, key) {
	    const copy = rows.slice();
		const num = (v) => (typeof v === "number" ? v : Number(v));
		copy.sort((a, b) => {
		  if (key === "esteps") {
		    return num(a.esteps) - num(b.esteps);                // ASC
		  } else if (key === "entropy") {
		    return num(b.entropy) - num(a.entropy);               // DESC
		  } else if (key === "expected") {
		    return num(a.expected) - num(b.expected);             // ASC
		  } else if (key === "maxBucket") {
		    return num(a.maxBucket) - num(b.maxBucket);           // ASC
		  }
		  return 0;		
		});
		return copy;	  
	  }
	  function resortSuggestTableBy(key) {
	    if (!lastSuggestRows.length) return;
		const sorted = sortRowsOneWay(lastSuggestRows, key); // Sort rows based on the selected key (E[steps], entropy, etc.)
		const nice =
		  key === "esteps" ? "Estimated E[steps]" :
		  key === "entropy" ? "Entropy" :
		  key === "expected" ? "E[cands]" :
		  key === "maxBucket" ? "Max Bucket" : key;
		renderSuggestRows(sorted, `by ${nice}`);
	  }
	  
	  /* ===== Mode wiring (Hard ‚Üî Pool) ===== */
	  function syncModeControls(){
	    const hard = byId('hardMode').checked;
		byId('poolSelect').disabled = hard;
		byId('modeNote').textContent = hard
		  ? 'Hard Mode ON'
		  : 'Hard Mode OFF';
	  }
	  
	  /* ===== Wire events ===== */
	  function wire(){
	    buildKeyboard(byId('gInc'),'gInc');
		buildKeyboard(byId('gExc'),'gExc');
		buildKeyboard(byId('pInc'),'pInc');
		buildKeyboard(byId('pExc'),'pExc');
		renderTabs();
		refresh();
		byId('searchBox').oninput=e=>{
		  state.search=e.target.value;
		  state.searchTester=buildSearchTester(state.search);
		  apply();
		};
		byId('clearAll').onclick=()=>{
		  state.globalInclude.clear();
		  state.globalExclude.clear();
		  for(let i=0;i<5;i++){
		    state.pos[i].include.clear();
			state.pos[i].exclude.clear();
		  }
		  state.search='';
		  state.searchTester=null;
		  byId('searchBox').value='';
		  refresh();
		  apply();
		};
		/* ===== Word List Button Style ===== */
		/* const f=byId('fileInput');
		byId('chooseFileBtn').onclick=()=>f.click();		
		f.onchange=async()=>{
		  const file=f.files?.[0];
		  if(!file) return;
		  try{
		    const t=await file.text();
			const w=parseWordsFromCsvText(t);
			if(!w.length) throw new Error('empty');
			loadWordsFromArray(w);
		  }catch(e){
		    alert('Load failed: '+e.message);
		  }
		  f.value='';
		};
		byId('use2309').onclick=()=>loadCsvFile('wordle_solutions_2309.csv');
		byId('use3200').onclick=()=>loadCsvFile('wordle_solutions_3200.csv');
		byId('use14855').onclick=()=>loadCsvFile('wordle_solutions_14855.csv'); */
		/* ===== Word List Dropdown Menu Style ===== */
		const fileInput   = byId('fileInput');
		const wordSelect  = byId('wordListSelect');
		if (fileInput) {
		  fileInput.onchange = async () => {
		    const file = fileInput.files?.[0];
			if (!file) return;
			try {
			  const text = await file.text();
			  const words = parseWordsFromCsvText(text);
			  if (!words.length) throw new Error('empty');
			  loadWordsFromArray(words);
			} catch (e) {
			  alert('Load failed: ' + e.message);
			} finally {
			  fileInput.value = '';
			}
		  };
		}
		if (wordSelect) {
		  wordSelect.onchange = async () => {
		    const v = wordSelect.value;
			try {
			  if (v === 'wl2309') {
			    await loadCsvFile('wordle_solutions_2309.csv');
			  } else if (v === 'wl3200') {
			    await loadCsvFile('wordle_solutions_3200.csv');
			  } else if (v === 'wl14855') {
			    await loadCsvFile('wordle_solutions_14855.csv');
			  } else if (v === 'custom') {
			    if (fileInput) fileInput.click();
			  }
			} catch (e) {
			  console.error(e);
			}
		  };
		}		
		const btnNext = byId('suggestNext');
		if (btnNext) btnNext.onclick = () => suggestNext();
		byId('resetSuggest').onclick=resetSuggestions;
		byId('stopBtn').onclick=()=>{
		  state.cancel=true;
		  byId('suggestStatus').textContent+=' (stopping‚Ä¶)';
		};
		byId('hardMode').onchange=syncModeControls;
		// byId('poolSelect').onchange=()=>{};
		// byId('wordListSelect').onchange=()=>{};
		syncModeControls();
		/* Original keydown event handler (before lockUI was triggered) */
		window.onkeydown = (e) => {
		  if (uiLocked) {
		    e.preventDefault(); return;
		  }
		  if(document.activeElement === byId('searchBox')) return;
		  const k = e.key, l = k.toLowerCase();
		  if(l >= '1' && l <= '5') {
		    state.activePos = Number(l) - 1;
			refresh();
			return;
		  }
		  if(k === '/') {
		    e.preventDefault();
			byId('searchBox').focus();
			return;
		  }
		  if(k === '@') {
		    e.preventDefault();
			byId('analyzeInput').focus();
			return;
		  }
		  if(k === '`') {
		    toggleTheme();
			return;
		  }
		  if(!/^[a-z]$/i.test(l)) return;
		  if(e.ctrlKey || e.metaKey) {
		    toggle(state.pos[state.activePos].exclude, state.pos[state.activePos].include, l);
		  } else if(e.altKey) {
		    toggle(state.globalExclude, state.globalInclude, l);
		  } else if(e.shiftKey) {
		    toggle(state.pos[state.activePos].include, state.pos[state.activePos].exclude, l);
		  } else {
		    toggle(state.globalInclude, state.globalExclude, l);
		  }
		  refresh();
		  apply();
		};
	  }
	  
	  /* ===== Global hotkey guard: ignore when typing in inputs/textareas/contenteditable ===== */
	  (function(){
	    const addGuard = (handler) => function(e){
		  const t = (e.target || document.activeElement);
		  const tag = (t && t.tagName || '').toLowerCase();
		  if (tag === 'input' || tag === 'textarea' || (t && t.isContentEditable)) return;
		  return handler.call(this, e);
		};
	  })();
	  
	  /* ===== Boot ===== */
	  document.addEventListener('DOMContentLoaded', async function(){
	    wire();
		try{
		  const base = await fetchCsv('wordle_solutions_2309.csv');
		  state.base2309 = base.slice();
		  loadWordsFromArray(base);
		  const sel = byId('wordListSelect');
		  if (sel) sel.value = 'wl2309';   // sync UI with default
		}catch(e){
		  console.error(e);
		}
	  });

	  document.addEventListener("DOMContentLoaded", function() {
	    /* ===== Function to toggle content visibility ===== */
		function toggleContent(sectionId) {
		  const content = document.getElementById(sectionId);
		  if (content.style.display === "none" || content.style.display === "") {
		    content.style.display = "block"; // Show content
		  } else {
		    content.style.display = "none"; // Hide content
		  }
		}
		/* ===== Add event listeners to each section header ===== */
		document.getElementById("wordListsToggle").addEventListener("click", function() {
		  toggleContent("wordListsContent");
		});
		document.getElementById("recommenderToggle").addEventListener("click", function() {
		  toggleContent("recommenderContent");
		});
		document.getElementById("searchHelpToggle").addEventListener("click", function() {
		  toggleContent("searchHelpContent");
		});
		document.getElementById("keyboardHintsToggle").addEventListener("click", function() {
		  toggleContent("keyboardHintsContent");
		});
	  });

	  document.addEventListener("DOMContentLoaded", () => {
	    const hSteps   = document.getElementById("sort-steps");
		const hEntropy = document.getElementById("sort-entropy");
		const hCands   = document.getElementById("sort-cands");
		const hBucket  = document.getElementById("sort-bucket");
		if (hSteps)   hSteps.addEventListener("click",   () => resortSuggestTableBy("esteps"));
		if (hEntropy) hEntropy.addEventListener("click", () => resortSuggestTableBy("entropy"));
		if (hCands)   hCands.addEventListener("click",   () => resortSuggestTableBy("expected"));
		if (hBucket)  hBucket.addEventListener("click",  () => resortSuggestTableBy("maxBucket"));
	  });
	  
	  /* ===== Analyze Word Logic ===== */
	  (function(){
	    function getCandidates(){
		  try{
		    if (window.state && Array.isArray(window.state.filtered) && window.state.filtered.length){
			  return window.state.filtered.slice();			  
			}
			if (window.state && Array.isArray(window.state.all) && window.state.all.length){
			  return window.state.all.slice();
			}		  
		  }catch(e){}
		  var lis = Array.from(document.querySelectorAll('#words li'));
		  if(lis.length) return lis.map(li=>li.textContent.trim().toLowerCase()).filter(w=>/^[a-z]{5}$/.test(w));
		  return [];		
		}
		function entropyOf(guess, set){
		  const map = partitionByPattern(set, guess);
		  const N = set.length;
		  let H = 0;
		  let maxb = 0;
		  let expSize = 0;
		  for(const arr of map.values()){
		    const m = arr.length;
			const p = m / N;
			maxb = Math.max(maxb, m);
			if(p>0){
			  H += -p * Math.log2(p);
			}
			expSize += m*m / N;
		  }
		  return {
		    entropy:H, expected:expSize, maxBucket:maxb, buckets:map
		  };
		}
		function EstepsOneLookahead(guess, set){
		  const part = partitionByPattern(set, guess);
		  const N = set.length;
		  let est = 0;
		  for (const [pat, subset] of part.entries()){
		    const m = subset.length;
			const p = m/N;
			if (pat === '22222'){
			  est += p * 1;  // exact hit: 1 step (this guess)
			} else {
			  let best = Infinity;
			  for (const g2 of subset){
			    const part2 = partitionByPattern(subset, g2);
				let e2 = 0;
				for (const [pat2, subset2] of part2.entries()){
				  const m2 = subset2.length;
				  const p2 = m2/subset.length;
				  if (pat2 === '22222') {
				    e2 += p2 * 1;
				  } else {
				    const expLeaf = (m2===1) ? 1 : 2;
					e2 += p2 * (1 + expLeaf);
				  }
				}
				if (e2 < best) best = e2;
			  }
			  est += p * (1 + best);
			}		  
		  }
		  return est;
		}
		function analyzeWord(word, set){
		  word = (word||'').toLowerCase();
		  if(!/^[a-z]{5}$/.test(word)) {
		    return {error:'Please enter a 5-letter word (A‚ÄìZ).'};
		  }
		  if(!set || !set.length) {
		    return {error:'No candidates loaded.'};
		  }
		  const fast = entropyOf(word, set);
		  let esteps = null;
		  try{
		    esteps = EstepsOneLookahead(word, set);
		  }catch(e){
		    esteps = null;
		  }
		  return {
		    word, esteps, entropy:fast.entropy, expected:fast.expected, maxBucket:fast.maxBucket
		  };
		}
		function renderAnalyzeRow(result){
		  const tbody = document.getElementById('analyzeTable');
		  if(!tbody) return;
		  tbody.innerHTML = '';
		  if(result.error){
		    const tr = document.createElement('tr');
			const td = document.createElement('td');
			td.colSpan = 5;
			td.textContent = result.error;
			tr.appendChild(td);
			tbody.appendChild(tr);
			return;
		  }
		  const tr = document.createElement('tr');
		  const fmt = (x)=> (x==null? '‚Äî' : (Math.round(x*1000)/1000));
		  const cells = [
		    result.word.toUpperCase(),
			(result.esteps==null? '‚Äî' : fmt(result.esteps)),
			fmt(result.entropy),
			fmt(result.expected),
			String(result.maxBucket)
		  ];
		  for(const v of cells){
		    const td=document.createElement('td');
			td.textContent=v;
			tr.appendChild(td);
		  }
		  tbody.appendChild(tr);
		}
		function onAnalyze(){
		  const set = getCandidates();
		  const val = (document.getElementById('analyzeInput').value||'').trim();
		  renderAnalyzeRow(analyzeWord(val, set));
		}
		document.addEventListener('DOMContentLoaded', function(){
		  const btn = document.getElementById('analyzeBtn');
		  const ipt = document.getElementById('analyzeInput');
		  if(btn) btn.addEventListener('click', onAnalyze);
		  if(ipt){
		    ['keydown','keypress','keyup'].forEach(ev=>ipt.addEventListener(ev, e=>e.stopPropagation()));
			ipt.addEventListener('keydown', (e)=>{ if(e.key==='Enter') onAnalyze(); });
		  }
		});	  
	  })();	  
	</script>

  </body>
</html>
