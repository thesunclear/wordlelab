/* Deeper E[steps] with an extra lookahead level:
   - Level 1: g (the candidate we are evaluating now)
   - Level 2: choose best g2 inside each bucket after g
   - Level 3: choose best g3 inside each bucket after g2
   - Then approximate the remaining leaf.

   Cost model:
   - Every actual guess (g, g2, g3, …) contributes +1 turn.
   - The “leaf” buckets add a small extra cost depending on size.
*/
function EstepsOneLookaheadLocalDeep(S, g) {
  const n = S.length;
  const parts1 = partitionByPattern(S, g);
  let est = 0;

  for (const [pat1, arr1] of parts1.entries()) {
    const p1 = arr1.length / n;

    if (pat1 === '22222') {
      // Solved immediately with g
      est += p1 * 1;
      continue;
    }

    // Choose best second guess g2 inside this bucket
    let bestE2 = Infinity;

    for (const g2 of arr1) {
      const parts2 = partitionByPattern(arr1, g2);
      let e2 = 0;

      for (const [pat2, arr2] of parts2.entries()) {
        const p2 = arr2.length / arr1.length;

        if (pat2 === '22222') {
          // Solved by g2
          e2 += p2 * 1;
          continue;
        }

        // For this child bucket arr2, choose best g3
        let bestE3 = Infinity;

        for (const g3 of arr2) {
          const parts3 = partitionByPattern(arr2, g3);
          let e3 = 0;

          for (const [pat3, arr3] of parts3.entries()) {
            const p3 = arr3.length / arr2.length;

            if (pat3 === '22222') {
              // Solved by g3
              e3 += p3 * 1;
            } else {
              // Leaf after g3: approximate remaining cost
              const leafSize = arr3.length;
              const expLeaf = (leafSize === 1) ? 1 : 2;
              // 1 for using g3, plus expected remaining steps in that tiny leaf
              e3 += p3 * (1 + expLeaf);
            }
          }

          if (e3 < bestE3) bestE3 = e3;
        }

        e2 += p2 * (1 + bestE3);
      }

      if (e2 < bestE2) bestE2 = e2;
    }

    // 1 for using g, plus best subtree under that bucket
    est += p1 * (1 + bestE2);
  }

  return est;
}